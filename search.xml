<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="test-math-equations">Test Math Equations</h2>
<p><span class="math display">\[
\begin{equation} \label{eq1}
e=mc^2
\end{equation}
\]</span></p>
<p>The famous matter-energy equation <span class="math inline">\(\eqref{eq1}\)</span> proposed by Einstein...</p>
<p><span class="math display">\[
\begin{equation} \label{eq2}
\begin{aligned}
a &amp;= b + c \\
  &amp;= d + e + f + g \\
  &amp;= h + i
\end{aligned}
\end{equation}
\]</span></p>
<p>Equation <span class="math inline">\(\eqref{eq2}\)</span> is a multi-line equation.</p>
<p><span class="math display">\[
\begin{align}
a &amp;= b + c \label{eq3} \\
x &amp;= yz \label{eq4}\\
l &amp;= m - n \label{eq5}
\end{align}
\]</span></p>
<p>There are three aligned equations: equation <span class="math inline">\(\eqref{eq3}\)</span>, equation <span class="math inline">\(\eqref{eq4}\)</span> and equation <span class="math inline">\(\eqref{eq5}\)</span>.</p>
]]></content>
  </entry>
  <entry>
    <title>Coding Experience | Job Searching</title>
    <url>/2020/04/16/00_%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%20General/</url>
    <content><![CDATA[<p>本文主要讲解找工过程中的coding practice/interview的一些经验。</p>
<a id="more"></a>
<h2 id="一些general的建议">一些General的建议:</h2>
<ul>
<li>公司通过算法题面试主要是希望考察大家的程序实现能力。</li>
<li>Interview过程中：先解释再写（也就是先和面试官确认要怎么解），写完再解释。</li>
<li>有些可以通过helper函数来简洁代码阅读过程的操作是值得尝试的。这样便于面试官理解。</li>
<li>面试不一定会要求你用最优复杂度的算法来解决问题。（尽量做到各种解法都了解）。</li>
<li>想要做到 Bug Free 最重要的是优化你的 <strong>Coding Style</strong> <strong>技巧:子函数 + 好的命名风格</strong></li>
<li>带名字的算法都不考的，就不要花时间去准备了。</li>
<li>主要练习：<strong>medium难度的题</strong>。</li>
<li><strong>不要花时间在Greedy算法</strong>。面试基本不会考，因为等同于考智力题或者是背诵题。一个面试官想要自己凭空创造出一个面试题是使用贪心算法的，是非常困难的。既然如此，如果面试中被问到了贪心算法，那么一定是一道经典的贪心问题，这类问题，我们可以称之为背诵题。因为大多数同学（除了智商很高，或者有算法竞赛经历的那一批），是不可能在面试的时候想得出解法的。贪心法，他不是“一个算法”，而是“一类算法”的统称，他更多的是一种高屋建瓴的算法思想，而不是具体实施的算法步骤。所以基本的情况就是，你在题目A里用了某个贪心算法解决了这个问题，然后这个题中用到的贪心法，永远也找不到第二个题用类似的方法来解决。
<ul>
<li>当然，面试中也不是说完全不可能碰到贪心算法，只是几率非常的小，你只需要<strong>“背诵”如下的一些几个题的贪心解法</strong>就了：<a href="http://www.jiuzhang.com/qa/2099/" target="_blank" rel="noopener">http://www.jiuzhang.com/qa/2099/</a></li>
</ul></li>
</ul>
<h2 id="与面试官的沟通技巧">与面试官的沟通技巧:</h2>
<ul>
<li>沟通的基本原则是什么?
<ul>
<li>不要把面试官当作你的 Interviewer，而要当作你的 Co-worker</li>
<li><strong>你可以问他索要提示，但是尽可能的不要问太多提示</strong>。正如工作中，你可以问你的同事寻求帮助，但是你问太多，问得事无巨细人家也很烦。</li>
<li><strong>沟通之后再动手</strong>。正如工作中，你的同事和你合作的时候，不会喜欢你一声不吭的先按照自己的想法把代码写了。</li>
<li><strong>意见不合别吵架，先认可对方的想法</strong>。正如工作中，你和同事讨论一个问题的不同解决方案的时候，最好先说，我觉得你的方法挺好的，然后再说，不过我觉得有个问题。</li>
</ul></li>
<li>写代码的时候该如何沟通？更好的办法是：
<ul>
<li>首先和面试官进行算法和实现方式上的沟通，从面试官那里得到确认你的方法是OK的，写出来是可以过的。</li>
<li>开始写代码时，只对一些可能对方不太看得懂的做解释。如果他正在玩手机没看你，就不用理他赶紧写完。</li>
<li>写完之后再一股脑给他解释代码。</li>
</ul></li>
</ul>
<p><img src="https://live.staticflickr.com/65535/49782371946_b269077258_o.png" style="zoom:25%"></p>
<p><img src="https://live.staticflickr.com/65535/49783076016_c5da3c91ea_o.png" style="zoom:30%"></p>
<p><img src="https://live.staticflickr.com/65535/49783130731_f32d4897cd_o.png" style="zoom:30%"></p>
<h2 id="如何做笔记">如何做笔记？</h2>
<ul>
<li>算法
<ul>
<li>用什么算法</li>
<li>为什么用这个算法(哪些条件)</li>
</ul></li>
<li>代码实现
<ul>
<li>有什么要注意的地方</li>
<li>有什么可优化的地方</li>
</ul></li>
<li>时空复杂度分析(主要是time complexity)</li>
<li>相关的题目有哪些做过的(跟哪个题比较像)</li>
</ul>
<h2 id="debug的基本步骤">DEBUG的基本步骤</h2>
<ol type="1">
<li><strong>重新读一遍程序 + 在程序的若干位置输出一些中间结果</strong>。</li>
<li><strong>设置special test case</strong>：找到一个非常小非常小的可以让你的程序出错的数据。比如空数组，空串，1-5个数的数组，一个字符的字符串。</li>
<li>定位了出错的部分之后，查看自己的程序该部分的逻辑是否有错。如果无法通过肉眼看出错误的部分，就<strong>一步步“模拟执行”程序</strong>，找出错误。</li>
</ol>
<h2 id="代码真的不是写出来就可以过-好的代码质量包括">代码真的不是写出来就可以过。 好的代码质量包括:</h2>
<ol type="1">
<li>Bug Free</li>
<li>好的代码风格(Coding Style)，包括变量名命名规范有意义，合理的使用空格，善用空行。</li>
<li>容易让人读懂的逻辑。要把复杂的事情用简单的方式，别把简单的事情写复杂了。</li>
<li>没有冗余代码</li>
<li>有边界检测和异常处理 (corner case)</li>
</ol>
<h2 id="几个技巧快速提高代码风格">几个技巧快速提高代码风格</h2>
<ol type="1">
<li>严格按照要求进行程序缩进 - format要合理</li>
<li><strong>二元运算符(作用两个变量的运算符)</strong> 左右两边加空格 (比如：四则运算)</li>
<li><strong>if, for 和括号之间</strong>加空格；即使 if / for 语句内部只有一句话，也要加上花括号(这条看情况吧)。</li>
<li><strong>变量名使用有意义的英文名</strong>，不要用a,b,c,s1,s2</li>
<li><strong>区分不同的<code>逻辑块</code>，逻辑块之间用空行隔开，简要注释每个部分做的事情</strong></li>
<li><strong>多用 Helper Function 或子函数</strong>，不要所有程序都写在一个大函数里</li>
</ol>
<h2 id="评测何时做好面试的准备三个维度">评测何时做好面试的准备：(三个维度)</h2>
<ol type="1">
<li>算法能力</li>
<li>Bug Free能力(每道题的平均提交次数)</li>
<li>题量(250-300)</li>
</ol>
<h2 id="刷题timeline">刷题TimeLine</h2>
<ul>
<li>按照各topic的建议刷题数，刷够</li>
<li>leetcode top interview</li>
<li>各大厂的leetcode题库</li>
</ul>
<p><strong>Note: 面试前专门去各大网站（比如 glassdor，一亩三分地，等等），搜索近期或以往的面经，这是挺重要的一个准备环节，因为至少可以了解到该公司的出题习惯和风格。</strong></p>
<h2 id="stl常用函数-纠错笔记-基本知识整理">STL常用函数 | 纠错笔记 | 基本知识整理</h2>
<h3 id="memory-栈区stack和堆区heap的区别">Memory: 栈区(stack)和堆区(heap)的区别</h3>
<ul>
<li><strong>栈区（stack）</strong>：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。</li>
<li><strong>堆区（heap）</strong>：一般是由程序员分配释放（比如allocate），若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。</li>
<li><strong>全局区（static）</strong>：也叫静态数据内存空间，存储全局变量和静态变量，全局变量和静态变量的存储是放一块的，初始化的全局变量和静态变量放一块区域，没有初始化的在相邻的另一块区域，程序结束后由系统释放。</li>
<li><strong>文字常量区</strong>：常量字符串(string)就是放在这里，程序结束后由系统释放。</li>
<li><strong>程序代码区</strong>：存放函数体的二进制代码。</li>
</ul>
<h3 id="常用c-data-types">常用C++ Data types</h3>
<p>All <a href="https://www.geeksforgeeks.org/variables-and-keywords-in-c/" target="_blank" rel="noopener">variables</a> use data-type during declaration to restrict the type of data to be stored. Therefore, we can say that data types are used to tell the variables the type of data it can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data-type with which it is declared. Every data type requires different amount of memory. - <strong>primitive data type</strong>: built-in or predefined data types and can be used directly by the user to declare variables 1. integer 2. character 3. boolean 4. floating point &amp; double floating point 5. valueness or void 6. Wide character - <strong>Abstract or user defined data types</strong>: defined by user itself. Like, defining <strong>a class in C++ or a structure</strong>. - <strong>Datatype Modifiers（类型修饰）</strong>: used with the built-in data types to modify the length of data that a particular data type can hold. Data type modifiers available in C++ are: - signed - unsigned - short - long <strong>1 byte = 8 bits; signed将range缩小一倍。== ==unsigned int: 0 ~ 2^32-1</strong> - 常见数据类型的范围： - char: <code>0 ~ 2^8 - 1(255)</code> - int: <code>-2147483648(-2^31)~2147483647(2^31 - 1)</code> - short int: <code>-32768(-2^15) ~ 32767(2^15 - 1)</code></p>
<pre><code>|     Data Type     | sizeof()               |
| :---------------: | ---------------------- |
|       char        | 1 byte = 8bits         |
|        int        | 4 bytes = 32bits       |
|     short int     | 2 bytes = 16bits       |
|     long int      | 8 bytes = 64bits       |
|  signed long int  | 8 bytes (范围正负平摊) |
| unsigned long int | 8bytes (只有正数一边)  |
|       float       | 4 bytes                |
|      double       | 8 bytes                |
|      wchar_t      | 4 bytes                |</code></pre>
<h3 id="null-与-空字符串的区别">null 与 空字符串的区别</h3>
<ul>
<li><strong>null 表示空对象</strong>: 类似于python里面的<code>s = None</code>; Java里面的<code>String s = null</code>; C++不能直接定义一个空对象，但是可以将一个引用绑定在一个nullptr上： <code>string &amp;p = *static_cast&lt;string *&gt;(nullptr);</code> 以上代码定义了一个空对象，我们不能对这个对象做任何操作，说明我们只是定义了变量，只是在==栈内存==中标记了这个变量的存在，但是并没有实际分配任何任何==堆内存==给这个变量，变量没有指向的地址，是个空对象。</li>
<li>C++:<code>string s;</code> 这个声明中，s不是空对象，是指向实实在在的堆内存的。只是这段内存中没有数据而已，s此时是个空串。我们可以对s做所有字符串的操作。例如取长度、拼接、替换、查找字符等。所以:
<ul>
<li>C++里就不用额外考虑为null的情况，一般就额外考虑empty string的情况。</li>
</ul></li>
<li>String <code>s1 = ""</code>; means that the empty String is assigned to s1. In this case, <code>s1.length()</code> is the same as <code>"".length()</code>, which will yield <code>0</code> as expected.</li>
<li>String <code>s2 = null;</code> means that <code>null</code> or "no value at all" is assigned to <code>s2</code>. So this one, <code>s2.length()</code> is the same as <code>null.length()</code>, which will yield a <code>NullPointerException</code> as you can't call methods on <code>null</code> variables (pointers, sort of) in Java.==</li>
</ul>
<h3 id="coding-style">Coding Style</h3>
<ol type="1">
<li><p>一种<strong>减少代码identation</strong>的书写形式</p>
<p>当for里面需要套if判断的时候，采用 <strong>第二种写法更节省indention</strong>，更显得简洁。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">for</span> ...</span><br><span class="line">  <span class="keyword">if</span> it<span class="number">'</span>s ok:</span><br><span class="line">    row <span class="number">1</span></span><br><span class="line">    row <span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">for</span> ...</span><br><span class="line">  <span class="keyword">if</span> its<span class="number">'</span> <span class="keyword">not</span> ok:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  row <span class="number">1</span></span><br><span class="line">  row <span class="number">2</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>for loop | 对于for loop的executing过程的理解</strong>：</p>
<p>首先initialize a iterate variable in the range of for loop，然后每次在执行loop内的内容时，都要先check condition（这个check意味着要执行condition这句）是否为true，即满足条件才会往内执行。执行完当前的loop内的内容后，update这个iterate variable，然后再判断是否满足条件，满足条件则继续进行；不满足则在update完后跳出。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误写法 - 可能会造成循环一直走不出而出现exceed memory limit error</span></span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">  ... <span class="comment">//存在改变q.size()的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line"><span class="keyword">int</span> n = q.<span class="built_in">size</span>(); <span class="comment">//这一步一定要单独拎出来！(在这种需要分层去traverse的情况下)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  ... <span class="comment">//存在改变q.size()的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为如果直接写到for loop的condition，每次i update后都需要去check condition是否为true，同时就会执行q.size()，而实际上一次iteration内的操作改变了q的size，所以很可能出现=="loop本来应到此跳出时却因为size被enlarge了就继续执行下一次iteration"==的情况。</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="ascii表">ASCII表</h2>
<ul>
<li>Capital Letters: A(65)-Z(90)</li>
<li>Lower Letters: a(97)-z(122)</li>
</ul>
<p><img src="https://live.staticflickr.com/65535/49782612018_83a8417d40_o.png" style="zoom:40%"></p>
<h2 id="string">String</h2>
<ul>
<li><p>如何判断两个字符串是否相等？ - 跟Python类似，C++也可以直接使用<code>==</code>比较字符串是否相等。 比如：<code>s1 == s2</code></p></li>
<li><p>如何遍历字符串? <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    s[i] ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c: s) &#123;</span><br><span class="line">    c...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//跟上一种写法一样，但是此时改变c的值会同时改变原字符串(因为用了reference)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>&amp; c: s) &#123;</span><br><span class="line">   c...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中s.size() 获取字符串的长度, 使用s[i]可以访问对应位置的字符。c++中的字符串是可变的，可以直接用s[i]=x的方式改变字符串。</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>string::back()</code> Returns a <strong>reference</strong> to the <strong>last character</strong> of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a>. This function shall not be called on <a href="http://www.cplusplus.com/string::empty" target="_blank" rel="noopener">empty strings</a>.</li>
<li><code>string::front()</code> Returns a <strong>reference</strong> to the <strong>first character</strong> of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a>. Unlike member <a href="http://www.cplusplus.com/string::begin" target="_blank" rel="noopener">string::begin</a>, which returns an iterator to this same character, this function returns a direct reference.</li>
<li><code>string::begin()</code> Returns an <strong>iterator</strong> pointing to the <strong>first character</strong> of the string.</li>
<li><code>string::end()</code> Returns an <strong>iterator</strong> pointing to the <strong>past-the-end</strong> character of the string. ==The past-the-end character is a theoretical character that would follow the last character in the string. It shall not be dereferenced==.</li>
<li><code>string::clear()</code> Erases the contents of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a>, which becomes an <a href="http://www.cplusplus.com/string::empty" target="_blank" rel="noopener">empty string</a> (with a <a href="http://www.cplusplus.com/string::length" target="_blank" rel="noopener">length</a> of <code>0</code> characters).</li>
<li><code>string::compare()</code> Compares the value of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a> object (or a substring) to the sequence of characters specified by its arguments. The compared string is the value of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a> object or -if the signature used has a <em>pos</em> and a <em>len</em> parameters- the substring that begins at its character in position <em>pos</em> and spans <em>len</em> characters. This string is compared to a comparing string, which is determined by the other arguments passed to the function. It returns 0 when they compare equal; &lt; 0 when ==Either the value of the first character that does not match is lower in the <em>compared string</em>, or all compared characters match but the <em>compared string</em> is shorter==; &gt; 0 when Either the value of the first character that does not match is greater in the <em>compared string</em>, or all compared characters match but the <em>compared string</em> is longer.
<ol type="1">
<li><code>str1.compare(str2)</code> 直接str1和str2比较</li>
<li><code>str1.compare(6, 5, str2)</code> str1的(6 ~ 10)index的substring和str2比较</li>
<li><code>str1.compare(6,5,str2,4,5)</code> str1的(6 ~ 10)index的substring和str2的(4 ~ 8)比较</li>
</ol></li>
<li><code>string::c_str()</code> Returns <strong>a pointer</strong> to <strong>an array that contains a null-terminated sequence of characters</strong> (i.e., a C-string) representing the current value of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a> object. This array includes the same sequence of characters that make up the value of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a> object <strong>plus an additional terminating null-character (<code>'\0'</code>) at the end</strong>.</li>
<li><code>string::empty()</code> Returns whether the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a> is empty (i.e. whether its <a href="http://www.cplusplus.com/string::length" target="_blank" rel="noopener">length</a> is <code>0</code>).</li>
<li><code>str.erase()</code> Erases part of the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a>, reducing its <a href="http://www.cplusplus.com/string::length" target="_blank" rel="noopener">length</a>:
<ol type="1">
<li><code>str.erase (10,8);</code> erase the substring starting from 10 and length is 8;</li>
<li><code>str.erase (str.begin()+9);</code> erase index为9的char; <code>str.erase(str.end() - 1)</code>删掉str的最后一位char;</li>
<li><code>str.erase (str.begin()+5, str.end()-9);</code> erase the substring from index为5(第6个) to index倒数第9</li>
</ol></li>
<li><code>string::find()</code> Searches the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a> for the first occurrence of the sequence specified by its arguments. When <em>pos</em> is specified, the search only includes characters at or after position <em>pos</em>, ignoring any possible occurrences that include characters before <em>pos</em>.
<ol type="1">
<li><code>str1.find(str2)</code> default pos is set to 0;</li>
<li><code>str1.find(str2, pos, n)</code> n is Length of sequence of characters to match.</li>
</ol></li>
<li><code>string::insert()</code> Inserts additional characters into the <a href="http://www.cplusplus.com/string" target="_blank" rel="noopener">string</a> <strong>right before the character indicated by <em>pos</em></strong> (or <em>p</em>).
<ol type="1">
<li><code>string&amp; insert (size_t pos, const string&amp; str);</code></li>
<li><code>insert (size_t pos, const string&amp; str, size_t subpos, size_t sublen)</code></li>
</ol></li>
</ul></li>
</ul>
<h3 id="vector">vector</h3>
<ul>
<li><code>v.insert(v.begin(), 5)</code></li>
<li>return an empty vector: <code>return vector&lt;string&gt;();</code> 或者 <code>return {};</code></li>
</ul>
<h3 id="map-set">map &amp; set</h3>
<ul>
<li><strong>unordered_map</strong>
<ul>
<li><code>unordered_map&lt;int, int&gt;</code> 初始值为0。因为 int 不是类类型，所以会进行零值初始化。这类似于<code>vector&lt;int&gt;</code>在初始化一个数组时，假设没有填充一个特定的值，也是默认为0。</li>
</ul></li>
<li><strong>unordered_set</strong>
<ul>
<li><code>unordered_multiset</code> 与<code>unordered_set</code>的唯一区别：前者可以allow different elements to have equivalent values.</li>
</ul></li>
<li><strong>pair的使用</strong>： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pair::pair example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // std::pair, std::make_pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // std::string</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product1;                     <span class="comment">// default constructor</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product2 (<span class="string">"tomatoes"</span>,<span class="number">2.30</span>);   <span class="comment">// value init</span></span><br><span class="line">  <span class="built_in">std</span>::pair &lt;<span class="built_in">std</span>::<span class="built_in">string</span>,<span class="keyword">double</span>&gt; product3 (product2);          <span class="comment">// copy constructor</span></span><br><span class="line"></span><br><span class="line">  product1 = <span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"lightbulbs"</span>),<span class="number">0.99</span>);   <span class="comment">// using make_pair (move)</span></span><br><span class="line"></span><br><span class="line">  product2.first = <span class="string">"shoes"</span>; <span class="comment">//first和second分别是pair的两个field</span></span><br><span class="line">  product2.second = <span class="number">39.90</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product1.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product1.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product2.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product2.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The price of "</span> &lt;&lt; product3.first &lt;&lt; <span class="string">" is $"</span> &lt;&lt; product3.second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="priority_queue">priority_queue</h3>
<ul>
<li>默认的是top()返回max，compare用的是less；如果compare换成greater，则返回min。</li>
<li><code>front()</code> : return next element (按照priority的规则排序的)</li>
<li><code>push()</code>: 插入一个element(要遵循priority的规则顺序)</li>
<li><code>pop_back()</code>: delete the element returned by <code>front()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">print_queue</span><span class="params">(T&amp; q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//top()返回的是max</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;) q.push(n); </span><br><span class="line">    print_queue(q);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; q2; <span class="comment">//top()返回的是min</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;) q2.push(n);</span><br><span class="line">    print_queue(q2);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Using lambda to compare elements.</span></span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123; <span class="keyword">return</span> (left ^ <span class="number">1</span>) &lt; (right ^ <span class="number">1</span>);&#125;;</span><br><span class="line">    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; q3(cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>&#125;) q3.push(n);</span><br><span class="line">    print_queue(q3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常考算法的经典题">常考算法的经典题</h2>
<p>整理前几章的题目到对应的typora page</p>
<h3 id="chapter-0-string相关">Chapter 0: String相关</h3>
<ul>
<li>Valid palindrome - 有不同类型的char混杂</li>
<li>Valid palindrome II - 可以删掉一个</li>
<li>Longest Palindrome - 只是计算最长的长度 - 用hashset/hashvector先存后删的方式来count</li>
<li>Longest Palindromic Substring - expandAroundCenter + 超过max就记录max</li>
<li>Subsets II - 基于dfs的backtracking + 限制条件以避免重复解</li>
</ul>
<h3 id="chapter-1-bfs">Chapter 1: BFS</h3>
<p><strong>主要应用分为：二叉树(tree)上的 BFS; 图(graph)上的 BFS; 矩阵上的 BFS; 拓扑排序 Topological Sorting。</strong> - Binary Tree Level Order Traversal - 利用BFS在traverse tree的时候的分层特性 - Serialize and Deserialize Binary Tree - serialize和deserialize都可以用BFS来实现，且是逆过程。==DFS(待implement)== - Clone Graph - 用bfs/dfs都行，关键在于是要借助于新老nodes之间的mapping来是实现deep copy - Word Ladder - 用bfs，关键在于要搞清楚在哪记录已经visit过的node(string) - Number of islands - bfs或者dfs，建议用bfs，因为dfs可能会很深导致stack overflow；==Union Find并查集(待implement)== - Course Schedule - 基于bfs或者dfs的topological sorting；==dfs待review== - Knight Shortest Path - simple graph里基于bfs - 双向BFS优化的解法 - Topological Sorting - general的拓扑排序求解合适的order - Sequence Reconstruction - 判断是不是有且只有一个合适的topological order</p>
<p><strong>遗留问题</strong>：</p>
<ul>
<li>Tological Sorting based on DFS</li>
<li>如何自己实现一个队列（queue）？分别用vector和LinkedList</li>
<li>用bfs实现：非递归的方式找所有方案</li>
<li>如果问最长路径，则要用Dynamic Programming。分层：走到第i层一定会经过第i - 1层。不可以分层：DFS。</li>
<li>Union Find</li>
<li>一道题：Alien Directionary</li>
<li>ppt上的related problems</li>
<li>随课教程的补充内容自学：另外两种宽度优先搜索算法。Bidirectional BFS。</li>
</ul>
<h3 id="chapter-3-binary-search">Chapter 3: Binary Search</h3>
<ul>
<li>Classical Binary search - 在sorted array里找到any target position</li>
<li>First position of target - 重点移right</li>
<li>First Bad Version - 和上一题同样的思路</li>
<li>Last position of target - 重点移left</li>
<li>Search in a big sorted array - 用exponential backoff去找到合适的范围</li>
<li>Find k closest elements - binary search定范围，然后背向two pointers按order append</li>
<li>Find Minimum in Rotated Sorted Array - <strong>"断崖式Array"</strong> - 转换为find the first number smaller than target(<strong>last number</strong>)</li>
<li>Search in Rotated Array - <strong>"断崖式Array"</strong> 思路1：基于上一题的思路，先确定division的位置，再确定target应该在的那一半range；然后用binary search；思路2：直接binary search，但是在移left和right的时候需要分在左半range和右半range两种情况的讨论。</li>
<li>Maximum Number in Mountain Sequence - <strong>"Mountain Array"</strong> 用 '增' 或者 '减' 作为判断条件的binary search</li>
<li>Find (any) peak element - <strong>"Mountain Array"</strong> 和上题同样的思路</li>
<li>Fast Power / Pow(x, n)- "快速幂算法" - 借用bianry search的思想</li>
</ul>
<h3 id="chapter-4-binary-tree">Chapter 4: Binary Tree</h3>
<p>主要是Traversal和Divide &amp; Conquer的解题思想。 - Minimum Subtree - 累赘地分步走(多写helper function咯); ResultType包装return值; Private fields / reference（需要这种全局性的比较）; - Binary Tree Paths - Divide &amp; conquer; traverse (NOT USE reference to avoid backtrack actively); - Lowest Common Ancestor - 多几个helper function做了重复遍历；one-time traverse but use divide &amp; conquer; - Lowest Common Ancestor III - one-time traverse &amp; use divide &amp; conquer &amp; RestultType; - Flattern Binary Tree to Linked List -</p>
<h3 id="chapter5-two-pointers">Chapter5: Two Pointers</h3>
<h3 id="chapter-6-implicit-graph-dfs">Chapter 6: Implicit Graph DFS</h3>
<ul>
<li>Subsets - 是否需要去重</li>
<li>Combination Sum - 相当于是subsets + sum限制剪枝 - 每个数是否可以重复使用 - 是否避重</li>
<li>k Sum II - 相当于combination sum + k 限制剪枝</li>
<li>Permutation类问题 - 两种解法：dfs backtrack + record visited status; non-recursion的get_next_permutation（需要记忆）</li>
<li>N-Queens 八皇后问题 - 记录一个对应于board size的矩阵，来记录各个node的访问状态，在recur之前根据the previous queen position来update整个status board。</li>
<li>Letter Combinations of a Phone Number - 很典型的dfs问题（只不过implicit）</li>
<li>找all possible solutions之类的问题
<ul>
<li>Split String：典型的dfs，search的每一步有多个选择，这也是dfs的意义：对于每一步来说，每一个选择都试一下，后面找不通了，回来试下一个选择。</li>
<li>Word Pattern II：pattern的char和str的substr对应。 -</li>
<li>Word Ladder II：既需要找到all solutions，而且要求shortest。- bfs限定shortest condition + dfs搜寻all possible solutions.</li>
</ul></li>
</ul>
<p><strong>遗留问题</strong>：</p>
<ul>
<li>涉及到trie结构的解法，解决hashmap可以解决的问题</li>
<li>教程</li>
</ul>
<h3 id="chapter7-hashheap">Chapter7: Hash/Heap</h3>
<ul>
<li><strong>LRU cache</strong> - doubly linked list + hashmap (num to node)</li>
<li><strong>Insert Delete GetRandom O(1)</strong> - vector + hashmap (num to index)</li>
<li><strong>First unique number in datastream</strong> - doubly linked list + hashmap (num to node) + hashmap (num to freq) to remove duplicates / hashset (recording duplicates -&gt; then we can choose not to add the number if already exists in duplicates hashset)</li>
<li><strong>First unique char in string</strong> - 和上一题完全一样的做法，只不过换成了char和string。</li>
<li><strong>Heapify</strong> - siftDown for every element of the array</li>
<li><strong>Ugly Number II</strong> - minHeap(always use the min number to generate next batch of ugly numbers) + hashset(recording visited number)
<ul>
<li><strong>K Closest Points</strong> - maxHeap / HeapSort</li>
<li><strong>Top K Largest Numbers</strong> - minHeap / HeapSort / QuickSort</li>
<li><strong>Top K Largest Numbers</strong> - minHeap</li>
<li><strong>Merger K Sorted Lists</strong> - quick sort all vals + recreating all nodes / recreating all nodes in the order of 打擂台 / minHeap / mergeSort</li>
<li><strong>Moving Average from Data Stream</strong> - queue with limited maxsize to store data</li>
<li><strong>Implement stack by Two Queues</strong></li>
<li><strong>Implement queue by Two Stacks</strong></li>
</ul></li>
</ul>
<p><strong>遗留问题</strong></p>
<ul>
<li>LRU cache - singly linked list version</li>
<li>Load balancer</li>
<li>Insert Delete GetRandom O(1) - with duplicates</li>
<li>First number in data stream II - with duplicates</li>
<li><strong>Moving Average from Data Stream</strong> - 前缀解法 / 滚动窗口解法</li>
</ul>
<h3 id="chapter8-memoization-search-dp">Chapter8: Memoization Search &amp; DP</h3>
<ul>
<li>Triangle</li>
<li>Wildcard Matching - '*' can be any char sequence.</li>
<li>Regular Expression Matching - '*' can repeat the preceding char zero or more times.</li>
<li>Word Pattern II - 只是为了说明不可以用memoization的情况</li>
<li>Word Break (可行性) - pure DFS / DFS + memoization + maxLen prunning / DP</li>
<li>Word Break II (all possible solutions) - DFS + memoization / DFS + dp-prunning</li>
<li>Word Break III (方案总数) DFS + memoization / pure DP</li>
<li>Palindrome Partitioning - 和Word Break II非常相似，前者是check word是否在dict里，而这题是check word是否是palindrome.</li>
<li>Stone Game - 区间型DP</li>
</ul>
<p><strong>遗留问题</strong>：</p>
<ul>
<li>Regular Expression Matching需要复习</li>
<li>区间型的Stone Game需要复习</li>
<li>背包型</li>
<li>序列型的Decode ways 和 双序列型的 Longest Common Subsequence &amp; Edit Distance</li>
</ul>
]]></content>
      <categories>
        <category>Coding Practice</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>宽度优先搜索(BFS) | 性价比很高</title>
    <url>/2020/04/16/01_%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(BFS)/</url>
    <content><![CDATA[<p>本文主要关于BFS算法的理解和相关经典习题的练习。</p>
<a id="more"></a>
<ol type="1">
<li><p><strong>什么是队列（Queue）？</strong></p>
<p>队列（queue）是一种采用<strong>先进先出</strong>（FIFO，first in first out）策略的抽象数据结构。比如生活中排队，总是按照先来的先服务，后来的后服务。队列在数据结构中举足轻重，其在算法中应用广泛，<strong>最常用的就是在宽度优先搜索(BFS）中，记录待扩展的节点</strong>。</p></li>
<li><p><strong>Queue内部存储数据的两种结构</strong></p>
<ul>
<li><strong>Array</strong>：数组对<strong>随机访问</strong>有较好性能。<strong><code>queue.pop()</code>的时间复杂度是O(n)。</strong></li>
<li><strong>LinkedList:</strong> 对<strong>插入</strong>和<strong>删除</strong>元素有较好性能。</li>
</ul></li>
<li><p>C++中，使用<queue>中的<code>queue</code>模板类，模板需两个参数，元素类型和容器类型，元素类型必要，而容器类型可选，默认<code>deque</code>，可改用<code>list</code>（链表）类型。</p></li>
<li><p><strong>==如何自己用数组实现一个队列？？？==</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Queue&lt;T&gt;::enqueue(T data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    queue_[rear_] = data;</span><br><span class="line">    rear_ = (rear_ + <span class="number">1</span>) % capacity_;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Queue&lt;T&gt;::dequeue()</span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Queue::dequeue() - Empty queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    data = queue_[front_];</span><br><span class="line">    front_ = (front_ + <span class="number">1</span>) % capacity_;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>什么时候使用宽搜？二叉树、图、矩阵、拓扑排序 </strong></p>
<ul>
<li><p><strong>树/图的遍历 Traversal in Graph</strong>: 比如给出无向连通图(Undirected Connected Graph)中的一个点，找到这个图里的所有点。</p>
<ol type="1">
<li><strong>层级遍历 Level Order Traversal</strong></li>
<li><strong>由点及面 Connected Component</strong></li>
<li><strong>拓扑排序 Topological Sorting</strong></li>
</ol></li>
<li><p><strong>最短路径 Shortest Path in Simple Graph</strong></p>
<ol type="1">
<li>最短路径算法有很多种，==BFS 是其中一种，但是必须是在<strong>Simple Graph (每条边长度都是1)</strong>中求最短路径==。</li>
<li>大部分<strong>Simple Graph</strong>中使用 BFS 算法时，都是无向图，也有可能是有向图，但是在面试中极少会出现。==A* search在面试中问过，推荐掌握。==</li>
<li>==如果问最长路径，则要用Dynamic Programming。分层：走到第i层一定会经过第i - 1层。不可以分层：DFS。==</li>
</ol></li>
<li><p>非递归的方式找所有方案 ???</p></li>
</ul></li>
<li><p><strong>二叉树中的BFS 和图的 BFS 最大的区别：</strong></p>
<p>==二叉树中无需使用 HashSet（C++: unordered_map, Python: dict) 来存储访问过的节点（丢进过 queue 里的节点）（这样做是为了避免存在环的情况，那么同一个节点就可能重复进入队列）==。</p></li>
<li><p><strong>图的表示形式</strong></p>
<ul>
<li><strong>邻接矩阵 Adjacency Matrix</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">/* A[i][j] = 1 means ith node connects to/with the the jth node</span></span><br><span class="line"><span class="comment">上式中，0号点和3号点有连边。1号点和2号点有连边。当然，每个点和自己也是默认有连边的。图中的 `0` 表示不连通，`1` 表示连通。邻接矩阵我们可以直接用一个二维数组表示，如`int[][] matrix;`。这种数据结构因为耗费 O(n^2) 的空间，所以在稀疏图上浪费很大，因此并不常用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>邻接表 Adjacency List - 相当于Adjacency Matrix的稀疏表示</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">/* A[i] is a list/vector of nodes who connect with ith node</span></span><br><span class="line"><span class="comment">上图表示 0 和 1 之间有连边，1 和 2 之间有连边，1 和 3 之间有连边。即每个点上存储自己有哪些邻居（有哪些连通的点）。</span></span><br><span class="line"><span class="comment">而邻接矩阵因为耗费空间过大，我们通常在工程中都是使用邻接表作为图的存储结构。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用HashMap 和 HashSet 搭配的方式来实现<strong>Adjacency Matrix</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;T, <span class="built_in">unordered_set</span>&lt;T&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通常这种hashmap的实现可以换成vector&lt;vector&lt;T&gt;&gt;来表示，但是如果在过程中需要check是否已有某个node，用map和set会比较方便，如果不需要的话就只是用固定数量的vector，就比较省空间时间。"vector可以方便实现就用vector，不方便就还是用hashmap或者hashset"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>而邻接矩阵因为耗费空间过大（尤其是在稀疏图上浪费很大），我们通常在工程中都是使用邻接表作为图的存储结构。</strong>另外，还可以用自定义的类来实现邻接表，但一般是在实际的工程中应用。</p></li>
<li><p><strong>拓扑排序 Topological Sorting</strong></p>
<ul>
<li><p><strong>Topological Order的定义</strong>：</p>
<p>在图论中，由一个有向无环图的顶点组成的序列，如果满足以下条件：</p>
<ol type="1">
<li><p>每个顶点出现且只出现一次；</p></li>
<li><p>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</p>
<p><strong>拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。</strong></p></li>
</ol></li>
<li><p>实际应用：</p>
<ul>
<li>检测编译时的循环依赖</li>
<li><strong>制定有依赖关系的任务的执行顺序</strong></li>
</ul></li>
<li><p>==Topological Sorting 并不是一种严格意义上的 Sorting Algorithm==。</p></li>
<li><p>==一张图的拓扑序列可以有很多个，也可能没有。== 拓扑排序只需要找到其中<code>一个</code>序列，无需找到<code>所有</code>序列。</p></li>
<li><p><strong>Topological Sorting Algorithm Description</strong> 在有向图中，如果存在一条有向边 A--&gt;B，那么我们认为这条边为 A 增加了一个==出度(<strong>out-degree</strong>)==，为 B 增加了一个==入度(<strong>in-degree</strong>)==。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Topological Sorting based on BFS</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 统计所有点的入度，并初始化拓扑序列为空。</span><br><span class="line"><span class="number">2.</span> 将所有入度为 <span class="number">0</span> 的点，放到宽度优先搜索的队列中</span><br><span class="line"><span class="number">3.</span> 将队列中的点一个一个的释放出来，放到拓扑序列中，每次释放出某个点 A 的时候，就访问 A 的相邻点（所有A指向的点），并把这些点的入度减去 <span class="number">1</span>。</span><br><span class="line"><span class="number">4.</span> 如果发现某个点的入度被减去 <span class="number">1</span> 之后变成了 <span class="number">0</span>，则放入队列中。</span><br><span class="line"><span class="number">5.</span> 直到队列为空时，算法结束。</span><br><span class="line"></span><br><span class="line">Tological Sorting based on DFS</span><br></pre></td></tr></table></figure></li>
<li><p><strong>拓扑排序的4种问法</strong></p>
<ul>
<li>return any topological order</li>
<li>whether exist topological sorder?</li>
<li>return all topological orders - <strong>DFS</strong></li>
<li>whether unique topological order? - <strong>Queue最多同时只有1个节点</strong></li>
</ul></li>
</ul></li>
<li><p><strong>BFS traversal模板</strong></p>
<ul>
<li><strong>复杂度：O(N + M) N为点数，M为边数。说是O(M)问题也不大，因为M一般都比N大。</strong></li>
<li><strong>需要分层遍历的bfs</strong>：
<ul>
<li>如果问题需要你区分开不同层级的结果信息，如binary tree level order traversal</li>
<li>简单图最短路径问题（因为要以traverse的level数量作为最短路径长度）</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; que;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;T, Hasher&gt; seen; <span class="comment">//记录是否已被访问过</span></span><br><span class="line"></span><br><span class="line">seen.insert(start);</span><br><span class="line">que.push(start);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = que.<span class="built_in">size</span>(); </span><br><span class="line">  <span class="comment">//必须单独拎出来。que.size()直接放在for loop的条件中会成为一个动态变化的值，因为这个每次loop都可能改变que的size。</span></span><br><span class="line">  <span class="comment">//所以必须先把当前层一共有多少个节点存在局部变量 size 中，才不会把下一层的节点也在当前层进行扩展。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> T &amp;head = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> T &amp;neighbor : head.neighbors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!seen.count(neighbor)) &#123;</span><br><span class="line">        seen.insert(neighbor);</span><br><span class="line">        que.push(neighbor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>无需分层遍历的bfs</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; que;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;T, Hasher&gt; seen; <span class="comment">//记录是否已被访问过(这在图中需要，但在二叉树中则不需要)</span></span><br><span class="line"></span><br><span class="line">seen.insert(start);</span><br><span class="line">que.push(start);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">  <span class="keyword">const</span> T &amp;head = que.front();</span><br><span class="line">  que.pop();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> T &amp;neighbor : head.neighbors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!seen.count(neighbor)) &#123; <span class="comment">//check whether already visited</span></span><br><span class="line">      seen.insert(neighbor); <span class="comment">//insert the just-visited node into visited set</span></span><br><span class="line">      que.push(neighbor); <span class="comment">//push into Queue-to-explore(存储等待被拓展到下一层的节点)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set/seen 与 queue 是一对好基友，无时无刻都一起出现，往 queue 里新增一个节点，就要同时丢到 set 里。</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对于矩阵R * C的情况，复杂度是O(RC + 2RC) = O(RC)</strong></p></li>
</ol>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//坐标变化数组(矩阵中允许四个方向的走法)</span></span><br><span class="line"><span class="keyword">int</span>[] deltaX = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] deltaY = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<ol start="11" type="1">
<li><p>其他常见实现方法：</p>
<ul>
<li><p><strong>两个队列来回迭代，来代表相邻的层级</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; q1, q2;</span><br><span class="line">q1.push(startNode);</span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q1.empty()) &#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = q1.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">    T head = q1.front();</span><br><span class="line">    q1.pop();</span><br><span class="line">    <span class="keyword">for</span> (all neighbors of head) &#123;</span><br><span class="line">      q2.push(neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  q1 = q2; <span class="comment">//直接通过将q1替换为q2，实现到下一层的转换</span></span><br><span class="line">  level++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 dummy node 来间隔不同的层级</strong>。</p>
<ul>
<li>Dummy Node 一般本身不存储任何实际有意义的值，通常用作"占位"，或者链表的“虚拟头”。如很多的链表问题中，我们会在原来的头head的前面新增一个节点，这个节点没有任何值，但是 next 指向 head。这样就会方便对 head 进行删除或者在前面插入等操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; q;</span><br><span class="line">q.push(startNode);</span><br><span class="line">q.push(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为有 dummy node 的存在，不能再用 isEmpty 了来判断是否还有没有拓展的节点了</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  T head = q.front();</span><br><span class="line">  q.pop();</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    level++;</span><br><span class="line">    q.push(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (all neighbors of head) &#123;</span><br><span class="line">    q.push(neighbor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>Summary</strong></p>
<ul>
<li>能用BFS的时候一定不要用DFS(除非面试官有特别要求)</li>
<li>找所有连通图（块）的问题，相当于是==<strong>找所有点，用BFS</strong>==。</li>
<li>找所有排列的问题，相当于是==<strong>找所有路径，用DFS</strong>==。</li>
<li>BFS的三中使用情况：
<ol type="1">
<li>图的遍历(由点及面，层级遍历)</li>
<li><strong>简单图</strong>最短路径</li>
<li>==拓扑排序必须掌握!!!== (依据indegree和outdegree的概念)</li>
</ol></li>
<li>是否需要层级遍历
<ol type="1">
<li><code>size = queue.size()</code></li>
</ol></li>
<li>坐标变化数组：
<ol type="1">
<li>deltaX, deltaY</li>
<li>inBound</li>
</ol></li>
</ul></li>
</ol>
<h1 id="图的遍历">图的遍历</h1>
<h2 id="binary-tree-level-order-traversal层级遍历">Binary Tree Level Order Traversal（层级遍历）</h2>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes' values. (ie, from left to right, level by level).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> results;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                TreeNode * node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                level.push_back(node-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            results.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="number-of-islands由点及面">Number of Islands（由点及面）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_x = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_y = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = m &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                bfs(grid, i, j); <span class="comment">//由点及面</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bfs traversal（由点及面）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">//调用此函数时m肯定是不为0的</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;r, c&#125;);</span><br><span class="line">        grid[r][c] = <span class="number">0</span>; <span class="comment">//note as visited by modifying into 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//explore neighbors</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    pair&lt;int, int&gt; next(curr.first + delta_x[j], curr.second + delta_y[j]);</span><br><span class="line">                    <span class="keyword">if</span> (next.first &lt; <span class="number">0</span> || next.first &gt;= m || next.second &lt; <span class="number">0</span> || next.second &gt;= n) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[next.first][next.second] == <span class="number">1</span>) &#123;</span><br><span class="line">                        q.push(next);</span><br><span class="line">                        grid[next.first][next.second] = <span class="number">0</span>; <span class="comment">//note as visited by modifying into 0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="serialize-and-deserialize-binary-tree-层级遍历">Serialize and Deserialize Binary Tree (层级遍历)</h2>
<p>Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called <code>serialization</code> and reading back from the file to reconstruct the exact same binary tree is <code>deserialization</code>.</p>
<ul>
<li><code>serialize</code>: This method will be invoked first, you should design your own algorithm to serialize a binary tree which denote by a root node to a string which can be easily deserialized by your own "deserialize" method later.</li>
<li><code>deserialize</code>: This method will be invoked second, the argument data is what exactly you serialized at method "serialize", that means the data is not given by system, it's given by your own serialize method. So the format of data is designed by yourself, and deserialize it here as you serialize it in "serialize" method.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在bfs的同时直接转成expected string，而不经过中间阶段（vector of nodes）</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ans += <span class="string">"#,"</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (to_string(node-&gt;val) + <span class="string">","</span>);</span><br><span class="line">            q.push(node-&gt;left);</span><br><span class="line">            q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.erase(ans.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">//删掉最后的','</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="function">TreeNode * <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> &amp;data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//vector&lt;string&gt; vals = split(data, ",");</span></span><br><span class="line">      	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vals;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> token;</span><br><span class="line">        <span class="keyword">while</span>(getline(ss, token, <span class="string">','</span>)) &#123;</span><br><span class="line">            vals.push_back(token);</span><br><span class="line">        &#125;</span><br><span class="line">      	</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode(atoi(vals[<span class="number">0</span>].c_str())); <span class="comment">//先要确定root</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q; <span class="comment">//用queue只是为了实现level order traversal</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//最关键的部分!!!</span></span><br><span class="line">        <span class="keyword">bool</span> isLeftChild = <span class="literal">true</span>; <span class="comment">//初始情况下是先走left child</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vals[i] != <span class="string">"#"</span>) &#123;</span><br><span class="line">                TreeNode * node = <span class="keyword">new</span> TreeNode(atoi(vals[i].c_str()));</span><br><span class="line">                <span class="keyword">if</span> (isLeftChild) q.front()-&gt;left = node;</span><br><span class="line">                <span class="keyword">else</span> q.front()-&gt;right = node;</span><br><span class="line">                q.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isLeftChild) q.pop(); <span class="comment">//关键步骤：当一个node的leftChild和rightChild都已经连接之后，就pop掉queue里这个parent。</span></span><br><span class="line">            isLeftChild = !isLeftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//split according to delim可以用stl的getline(ss, token, delim)来代替。</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="built_in">string</span> &amp;data, <span class="built_in">string</span> delim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastInd = <span class="number">0</span>, ind;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; results;</span><br><span class="line">        <span class="keyword">while</span>((ind = data.<span class="built_in">find</span>(delim, lastInd)) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = data.substr(lastInd, ind - lastInd);</span><br><span class="line">            results.push_back(tmp);</span><br><span class="line">            lastInd = ind + delim.<span class="built_in">size</span>(); <span class="comment">//update start searching index</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//单独push最后一个substring</span></span><br><span class="line">        <span class="keyword">if</span> (lastInd &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = data.substr(lastInd, data.<span class="built_in">size</span>() - lastInd);</span><br><span class="line">            results.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="clone-graph">Clone Graph</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="comment">//用map的目的一是为了后面去check是否visited，二是为了建立一一对应的关系而实现deepcopy.</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode* <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        UndirectedGraphNode* newNode = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class="line">        <span class="built_in">map</span>[node] = newNode;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;UndirectedGraphNode*&gt; q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            UndirectedGraphNode* curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode* neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(neighbor) == <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[neighbor] = <span class="keyword">new</span> UndirectedGraphNode(neighbor-&gt;label);</span><br><span class="line">                    q.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>[curr]-&gt;neighbors.push_back(<span class="built_in">map</span>[neighbor]); <span class="comment">//!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode* <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(node) == <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">map</span>[node] = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode* neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">                <span class="built_in">map</span>[node]-&gt;neighbors.push_back(cloneGraph(neighbor));<span class="comment">//clongGraph return的是和输入对应的copied node</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="简单图最短路径">简单图最短路径</h1>
<h2 id="shortest-path-in-undirected-graph">Shortest Path in Undirected Graph</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for Undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="built_in">vector</span>&lt;UndirectedGraphNode*&gt; graph, UndirectedGraphNode* A, UndirectedGraphNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;UndirectedGraphNode*&gt; q;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;UndirectedGraphNode*&gt; visited; <span class="comment">//记录visited，避免重复</span></span><br><span class="line">        q.push(A);</span><br><span class="line">        visited.insert(A);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                UndirectedGraphNode* curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (UndirectedGraphNode* neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (neighbor == B) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.push(neighbor);</span><br><span class="line">                    visited.insert(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双向宽度优先搜索算法bidirectional-bfs">双向宽度优先搜索算法（<strong>Bidirectional BFS</strong>）</h2>
<ul>
<li><p>无向图</p></li>
<li><p>所有边的长度都为 1 或者长度都一样</p></li>
<li><p>同时给出了起点和终点</p>
<p>以上 3 个条件都满足的时候，可以使用双向宽度优先搜索来<strong>求起点和终点的最短距离</strong>。</p>
<p>如果在面试中被问到了如何优化 BFS 的问题，Bidirectional BFS 几乎就是标准答案了。</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法描述：双向宽度优先搜索本质上还是BFS，只不过变成了起点向终点和终点向起点同时进行扩展，直至两个方向上出现同一个子节点，搜索结束。我们还是可以利用队列来实现：一个队列保存从起点开始搜索的状态，另一个保存从终点开始的状态，两边如果相交了，那么搜索结束。起点到终点的最短距离即为起点到相交节点的距离与终点到相交节点的距离之和。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设单向BFS需要搜索 N 层才能到达终点，每层的判断量为 X，那么总的运算量为 X ^ N. 如果换成是双向BFS，前后各自需要搜索 N / 2 层，总运算量为 2 * X ^ &#123;N / 2&#125; 。如果 N 比较大且X 不为 1，则运算量相较于单向BFS可以大大减少，差不多可以减少到原来规模的根号的量级。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doubleBFS</span><span class="params">(Node * start, Node * <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node&gt; startQ, endQ;</span><br><span class="line">  startQ.push(start);</span><br><span class="line">  endQ.push(<span class="built_in">end</span>);</span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;Node&gt; startVisited, endVisited;</span><br><span class="line">  startVisited.insert(start);</span><br><span class="line">  endVisited.insert(<span class="built_in">end</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!startQ.empty() || !endQ.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> startSize = startQ.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">step</span>++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startSize; i++) &#123;</span><br><span class="line">      Node * curr = startQ.front();</span><br><span class="line">      startQ.pop();</span><br><span class="line">      <span class="keyword">for</span> (Node * neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startVisited.count(neighbor)) &#123; <span class="comment">//重复节点</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endVisited.count(neighbor)) &#123; <span class="comment">//相交</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        startQ.push(neighbor);</span><br><span class="line">        startVisited.insert(neighbor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> endSize = endQ.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">step</span>++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endSize; i++) &#123;</span><br><span class="line">      Node * curr = endQ.front();</span><br><span class="line">      endQ.pop();</span><br><span class="line">      <span class="keyword">for</span> (Node * neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (endVisited.count(neighbor)) &#123; <span class="comment">//重复节点</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (startVisited.count(neighbor)) &#123; <span class="comment">//相交</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        endQ.push(neighbor);</span><br><span class="line">        endVisited.insert(neighbor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不连通</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="word-ladder隐式简单图">Word Ladder（隐式简单图）</h2>
<p>Given two words (<em>start</em> and <em>end</em>), and a dictionary, find <strong>the shortest transformation sequence from <em>start</em> to <em>end</em></strong>, output the length of the sequence. Transformation rule such that:</p>
<ol type="1">
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the dictionary. (<strong>Start and end words do not need to appear in the dictionary</strong> )</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 自己的solution：BFS traverse nodes level by level; <span class="keyword">return</span> level + <span class="number">1</span> when the next node matches <span class="built_in">end</span>.</span><br><span class="line"># 一个难点在于：Implicit BFS - 要自己去构建graph，这里的每个node是<span class="built_in">string</span></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ladderLength(<span class="built_in">string</span> &amp;start, <span class="built_in">string</span> &amp;<span class="built_in">end</span>, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//corner case</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(start);</span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(start) != dict.<span class="built_in">end</span>()) dict.erase(start); <span class="comment">//通过erase已经访问过的string来记录为visited</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123; <span class="comment">//开始bfs</span></span><br><span class="line">            <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//explore neighbors of curr</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//枚举替换位置</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; <span class="comment">//枚举替换字母</span></span><br><span class="line">                        <span class="built_in">string</span> tmp = curr;</span><br><span class="line">                        <span class="keyword">if</span> (tmp[i] == <span class="string">'a'</span> + j) <span class="keyword">continue</span>;</span><br><span class="line">                        tmp[i] = <span class="string">'a'</span> + j;</span><br><span class="line">                        <span class="keyword">if</span> (tmp == <span class="built_in">end</span>) <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(tmp) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            q.push(tmp);</span><br><span class="line">                            dict.erase(tmp); <span class="comment">//通过erase已经访问过的string来记录为visited</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">//count levels traversed during bfs</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="knight-shortest-pathgrid简单图">Knight Shortest Path（grid简单图）</h2>
<p>Given a knight in a chessboard (a binary matrix with <code>0</code> as empty and <code>1</code> as barrier) with a <code>source</code> position, find <strong>the shortest path to a <code>destination</code> position</strong>, return the length of the route. Return <code>-1</code> if destination cannot be reached.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_x = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_y = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid, Point &amp;source, Point &amp;destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[destination.x][destination.y] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (source.x == destination.x &amp;&amp; source.y == destination.y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;Point&gt; q;</span><br><span class="line">        q.push(source);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//level数就是可能走的步数</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                Point curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (Point &amp;next : get_next(curr, grid)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (next.x == destination.x &amp;&amp; next.y == destination.y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//helper</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">get_next</span><span class="params">(Point &amp;p, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Point&gt; results;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_x = p.x + delta_x[i];</span><br><span class="line">            <span class="keyword">int</span> next_y = p.y + delta_y[i];</span><br><span class="line">            <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= m || next_y &lt; <span class="number">0</span> || next_y &gt;= n) <span class="keyword">continue</span>;<span class="comment">//out of bounds</span></span><br><span class="line">            <span class="keyword">if</span> (grid[next_x][next_y] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//避开障碍点</span></span><br><span class="line">            <span class="function">Point <span class="title">next_p</span><span class="params">(next_x, next_y)</span></span>;</span><br><span class="line">            results.push_back(next_p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="knight-shortest-path-ii">Knight Shortest Path II</h2>
<p>起点和终点分别是左上角和右下角。移动过程中限制"只能往右移动"。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_x = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_y = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">//only from left to right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next_x = curr.first + delta_x[j];</span><br><span class="line">                    <span class="keyword">int</span> next_y = curr.second + delta_y[j];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= n || next_y &gt;= m ) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[next_x][next_y]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (visited[next_x][next_y]) <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; next = &#123;next_x, next_y&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (next.first == n - <span class="number">1</span> &amp;&amp; next.second == m - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; "x: " &lt;&lt; next.first &lt;&lt; " y: " &lt;&lt; next.second &lt;&lt; endl;</span></span><br><span class="line">                    visited[next.first][next.second] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DP解法：每个点都有至多4个前缀点，直接求最小值转移即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, INT_MAX))</span></span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">              	<span class="comment">//以下四种情况分别对应四个前缀点</span></span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">2</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; j - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">2</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i + <span class="number">1</span>][j - <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; f[i - <span class="number">2</span>][j - <span class="number">1</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">2</span> &lt; n &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; f[i + <span class="number">2</span>][j - <span class="number">1</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i + <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (f[n - <span class="number">1</span>][m - <span class="number">1</span>] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#拓扑排序问题</p>
<h2 id="topological-sorting原型">Topological Sorting（原型）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for Directed graph.</span></span><br><span class="line"><span class="comment"> * struct DirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;DirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     DirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;DirectedGraphNode*&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Calculating indegree</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;DirectedGraphNode*, <span class="keyword">int</span>&gt; node_to_degree;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DirectedGraphNode* neighbor : graph[i]-&gt;neighbors) &#123;</span><br><span class="line">                node_to_degree[neighbor]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*因为有些nodes在前面并没有被统计到，比如&#123;0,1,2,3,4#1,3,4#2,1,4#3,4#4&#125;这个case就没有先统计到0。</span></span><br><span class="line"><span class="comment">        所以需要这一步来检查没统计到map里的nodes，将in-degree主动设为0（这也是前面没被统计到的原因）。*/</span></span><br><span class="line">        <span class="keyword">for</span> (DirectedGraphNode* node : graph) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_to_degree.count(node) == <span class="number">0</span>) &#123;</span><br><span class="line">                node_to_degree[node] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;DirectedGraphNode*&gt; q;</span><br><span class="line">        <span class="comment">//先是所有indegree为0的nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : node_to_degree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.second == <span class="number">0</span>) q.push(m.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照bfs的套路来，每遇到新的indegree=0的node(要先--)，就push到queue中。</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                DirectedGraphNode* curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans.push_back(curr);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (DirectedGraphNode* neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">                    node_to_degree[neighbor]--;</span><br><span class="line">                    <span class="keyword">if</span> (node_to_degree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.push(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="course-schedule-是否可行">Course Schedule (是否可行)</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//裸拓扑排序（不考虑分层）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//未在prerequisites中被统计到的话，就自动归为0了。</span></span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p: prerequisites) &#123;</span><br><span class="line">            g[p.second].insert(p.first);  </span><br><span class="line">            degree[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">//push in-degree-0 nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : g[curr]) &#123;</span><br><span class="line">                degree[neighbor]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[neighbor] == <span class="number">0</span>) q.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">        <span class="comment">//与count对应的node的sequence如果正好包括全部的node，那就说明形成了topologic order。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过bfs去check每一个course，是否会形成一个循环（如果有会形成循环的，则不能finish；如果没有，则能finish）。 </span></span><br><span class="line"><span class="comment">// - runtime error(一些冗长的case)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//create graph: 以每门课的prerequistes作为neighbors</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre : prerequisites) &#123;</span><br><span class="line">            g[pre.second].insert(pre.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isCyle(i, g)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check whether course forms a cycle starting from course and ending with course</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCyle</span><span class="params">(<span class="keyword">int</span> course, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(course);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">        visited.insert(course);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[curr]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (neighbor == course) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    q.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="course-schedule-ii-一种拓扑order">Course Schedule II （一种拓扑order）</h2>
<ul>
<li>这里值得注意的是：对于prerequisites中可能会出现重复的情况，一种就是用multiset相同的数也都insert进去，后面再去掉；另外一种就是用unordered_set, 出现相同的情况直接跳过（不然的话，degree增加了，但实际的neighbors没有发生变化，导致出错）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[p.second].count(p.first) == <span class="number">0</span>) &#123; <span class="comment">//只是为了避免出现相同prerequisite的情况</span></span><br><span class="line">                g[p.second].insert(p.first);</span><br><span class="line">                degree[p.first]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            order.push_back(curr);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : g[curr]) &#123;</span><br><span class="line">                degree[next]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[next] == <span class="number">0</span>) q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (order.<span class="built_in">size</span>() == numCourses) <span class="keyword">return</span> order;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sequence-reconstruction-unique-order">Sequence Reconstruction (Unique Order)</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// seqs里的seq是sequence的subsequence，比如[1, 2]，这意味着1指向2。</span></span><br><span class="line"><span class="comment">// 判断是否有Unique Topological Order：每次iteration的时候queue里只有一个node，其他的做法和general的类似。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param org: a permutation of the integers from 1 to n</span></span><br><span class="line"><span class="comment">     * @param seqs: a list of sequences</span></span><br><span class="line"><span class="comment">     * @return: true if it can be reconstructed only one or false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;org, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;seqs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = org.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count the total length of all seqs</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq : seqs) &#123;</span><br><span class="line">            count += seq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (seq.<span class="built_in">size</span>() &gt;= <span class="number">1</span> &amp;&amp; (seq[<span class="number">0</span>] &lt; <span class="number">1</span> || seq[<span class="number">0</span>] &gt; n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; seq.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seq[i] &lt; <span class="number">1</span> || seq[i] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//避免重复计算indegree，比如这个case: [[5,2,6,3],[4,1,5,2]] 5-&gt;2有两次</span></span><br><span class="line">                <span class="keyword">if</span> (graph[seq[i - <span class="number">1</span>]].count(seq[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    graph[seq[i - <span class="number">1</span>]].insert(seq[i]); <span class="comment">//相邻node之间有前后指向关系</span></span><br><span class="line">                    indegree[seq[i] - <span class="number">1</span>]++; <span class="comment">//node n 对应到 indegree的第n-1位</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*case: [1]</span></span><br><span class="line"><span class="comment">                []</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; indegree.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) q.push(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="comment">//queue should always have only one node</span></span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[curr]) &#123;</span><br><span class="line">                indegree[next - <span class="number">1</span>]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[next - <span class="number">1</span>] == <span class="number">0</span>) q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr != org[k]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//而且唯一的那一个要和unique order里的对应node一样</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> k == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding Practice</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Duke Master Experience</title>
    <url>/2020/04/15/master@duke/</url>
    <content><![CDATA[<p>Here is a simple overview of my study and life experience at Duke University, during which I've been pursuing my Master degree. Two Years is actually very short. Lots of regret though.</p>
<a id="more"></a>
<h2 id="a-bit-background">A bit Background</h2>
<p>I finished my undergraduate study at Sun Yat-Sen University in Guangzhou (China) in 2018 and got admitted into Duke luckily. - Undergraduate Major: Energy and Dynamics Engineering - Master Major: Mechanical Engieering (Robotics Track)</p>
<figure>
<img src="https://live.staticflickr.com/65535/49781871483_7d80819d0e_o.jpg" alt="" /><figcaption>duke chapel from Our State Magazine</figcaption>
</figure>
<h2 id="timeline">Timeline</h2>
<h3 id="fall-aug---dec">2018 Fall (Aug - Dec)</h3>
<ul>
<li>ME627 - Linear Systems Theory (core)</li>
<li>ECE551 - Programming, Data Structures, and Algorithms in C++ (core)</li>
<li>MATH541 - Applied Stochastic Process (Math)</li>
</ul>
<h3 id="winter-vacation">2018 Winter Vacation</h3>
<ul>
<li>Move to live with a local christian church</li>
<li>One-Week Trip at LA with Yellow</li>
<li>One-Week Deep Learning Course (like a very short-term workshop)</li>
</ul>
<h3 id="spring-jan---may">2019 Spring (Jan - May)</h3>
<ul>
<li>CS527 - Computer Vision (core)</li>
<li>STA561 - Probabilistic Machine Learning (elective)</li>
<li>ME555: Advanced Robotics System Design (core)</li>
<li>Summer Internship Searching</li>
</ul>
<h3 id="summer-vacation">2019 Summer Vacation</h3>
<ul>
<li>Summer Internship @ Aqueti in Kunshan, nearby DKU</li>
</ul>
<h3 id="fall-aug---dec-1">2019 Fall (Aug - Dec)</h3>
<ul>
<li>ECE590: Smart Camera (elective)</li>
<li>ECE588: Image Video Procession (elective)</li>
<li>CS671: Machine Learning (core)</li>
<li>Indepdent Study with Dr. David Brady (elective)</li>
<li>Full-time Job Searching</li>
</ul>
<h3 id="spring-jan---now">2020 Spring (Jan - NOW)</h3>
<ul>
<li>Continue Full-time Job Searching</li>
<li>Graduate Poster-based Project</li>
<li>Visa Application for My Potential Career</li>
<li>Stay at Home due to COVID-19</li>
</ul>
<h2 id="what-i-did-well">What I did well</h2>
<ul>
<li>overcame the gap from traditional engineering that I don't like to software-related engineering field that I think I can do well</li>
<li>adapted well into living a western-style life</li>
<li>met some nice friends</li>
<li>well.... (I'll fill up later)</li>
</ul>
<h2 id="what-i-did-not-well">What I did not well</h2>
<ul>
<li>did not prepare well or grab enough information before arriving at Duke</li>
<li>got lagged behind while compared with other peers</li>
<li>got upset easily in front of interview failures</li>
</ul>
<h2 id="goals-in-april">Goals in April</h2>
<ul>
<li>maintain and improve my personal website apperance and functionalities</li>
<li>udacity - becoming MLE</li>
<li>udacity - a/b testing</li>
<li>coursera nlp</li>
<li>stanford nlp cs224</li>
<li>spark projects review</li>
<li>hadoop projects review</li>
<li>九章算法强化班</li>
<li>九章系统设计班</li>
</ul>
<p><strong>Let's see what I'll be up to in May......</strong></p>
<h2 id="some-resume-experience-backup">Some Resume Experience Backup</h2>
<ul>
<li>Connected Vehicles on Traditional Traffic Flow (Feb/2018 - May/2018)
<ul>
<li><strong>Model Parameters Calibration:</strong> Calibrated Intelligent Driver Model and Cooperative Intelligent Driver Model that characterizes the car-following dynamics of Human-driven Vehicle (HV) and Connected Vehicle (CV) respectively.</li>
<li><strong>Numeric Simulation &amp; Parameter Tuning</strong>: Utilized Matlab to numerically simulate dynamics of HVs and CVs running on a one-way straight road; Tuned parameters related to cooperative strategy among CVs to maximize the positive effects.</li>
</ul></li>
</ul>
]]></content>
  </entry>
</search>
