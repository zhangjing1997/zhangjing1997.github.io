<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Duke Master Experience</title>
    <url>/2020/04/15/master@duke/</url>
    <content><![CDATA[<p>Here is a simple overview of my study and life experience at Duke University, during which I've been pursuing my Master degree. Two Years is actually very short. Lots of regret though.</p>
<a id="more"></a>
<h2 id="a-bit-background">A bit Background</h2>
<p>I finished my undergraduate study at Sun Yat-Sen University in Guangzhou (China) in 2018 and got admitted into Duke luckily. - Undergraduate Major: Energy and Dynamics Engineering - Master Major: Mechanical Engieering (Robotics Track)</p>
<h2 id="timeline">Timeline</h2>
<h3 id="fall-aug---dec">2018 Fall (Aug - Dec)</h3>
<ul>
<li>ME627 - Linear Systems Theory (core)</li>
<li>ECE551 - Programming, Data Structures, and Algorithms in C++ (core)</li>
<li>MATH541 - Applied Stochastic Process (Math)</li>
</ul>
<h3 id="winter-vacation">2018 Winter Vacation</h3>
<ul>
<li>Move to live with a local christian church</li>
<li>One-Week Trip at LA with Yellow</li>
<li>One-Week Deep Learning Course (like a very short-term workshop)</li>
</ul>
<h3 id="spring-jan---may">2019 Spring (Jan - May)</h3>
<ul>
<li>CS527 - Computer Vision (core)</li>
<li>STA561 - Probabilistic Machine Learning (elective)</li>
<li>ME555: Advanced Robotics System Design (core)</li>
<li>Summer Internship Searching</li>
</ul>
<h3 id="summer-vacation">2019 Summer Vacation</h3>
<ul>
<li>Summer Internship @ Aqueti in Kunshan, nearby DKU</li>
</ul>
<h3 id="fall-aug---dec-1">2019 Fall (Aug - Dec)</h3>
<ul>
<li>ECE590: Smart Camera (elective)</li>
<li>ECE588: Image Video Procession (elective)</li>
<li>CS671: Machine Learning (core)</li>
<li>Indepdent Study with Dr. David Brady (elective)</li>
<li>Full-time Job Searching</li>
</ul>
<h3 id="spring-jan---now">2020 Spring (Jan - NOW)</h3>
<ul>
<li>Continue Full-time Job Searching</li>
<li>Graduate Poster-based Project</li>
<li>Visa Application for My Potential Career</li>
<li>Stay at Home due to COVID-19</li>
</ul>
<h2 id="what-i-did-well">What I did well</h2>
<ul>
<li>overcame the gap from traditional engineering that I don't like to software-related engineering field that I think I can do well</li>
<li>adapted well into living a western-style life</li>
<li>met some nice friends</li>
<li>well.... (I'll fill up later)</li>
</ul>
<h2 id="what-i-did-not-well">What I did not well</h2>
<ul>
<li>did not prepare well or grab enough information before arriving at Duke</li>
<li>got lagged behind while compared with other peers</li>
<li>got upset easily in front of interview failures</li>
</ul>
<h2 id="goals-in-april">Goals in April</h2>
<ul>
<li>maintain and improve my personal website apperance and functionalities</li>
<li>udacity - becoming MLE</li>
<li>udacity - a/b testing</li>
<li>coursera nlp</li>
<li>stanford nlp cs224</li>
<li>spark projects review</li>
<li>hadoop projects review</li>
<li>九章算法强化班</li>
<li>九章系统设计班</li>
</ul>
<p><strong>Let's see what I'll be up to in May......</strong></p>
<h2 id="some-resume-experience-backup">Some Resume Experience Backup</h2>
<ul>
<li>Connected Vehicles on Traditional Traffic Flow (Feb/2018 - May/2018)
<ul>
<li><strong>Model Parameters Calibration:</strong> Calibrated Intelligent Driver Model and Cooperative Intelligent Driver Model that characterizes the car-following dynamics of Human-driven Vehicle (HV) and Connected Vehicle (CV) respectively.</li>
<li><strong>Numeric Simulation &amp; Parameter Tuning</strong>: Utilized Matlab to numerically simulate dynamics of HVs and CVs running on a one-way straight road; Tuned parameters related to cooperative strategy among CVs to maximize the positive effects.</li>
</ul></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>宽度优先搜索(BFS) | 性价比很高</title>
    <url>/2020/04/16/01_%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(BFS)/</url>
    <content><![CDATA[<p>本文主要关于BFS算法的理解和相关经典习题的练习。</p>
<a id="more"></a>
<ol type="1">
<li><p><strong>什么是队列（Queue）？</strong></p>
<p>队列（queue）是一种采用<strong>先进先出</strong>（FIFO，first in first out）策略的抽象数据结构。比如生活中排队，总是按照先来的先服务，后来的后服务。队列在数据结构中举足轻重，其在算法中应用广泛，<strong>最常用的就是在宽度优先搜索(BFS）中，记录待扩展的节点</strong>。</p></li>
<li><p><strong>Queue内部存储数据的两种结构</strong></p>
<ul>
<li><strong>Array</strong>：数组对<strong>随机访问</strong>有较好性能。<strong><code>queue.pop()</code>的时间复杂度是O(n)。</strong></li>
<li><strong>LinkedList:</strong> 对<strong>插入</strong>和<strong>删除</strong>元素有较好性能。</li>
</ul></li>
<li><p>C++中，使用<queue>中的<code>queue</code>模板类，模板需两个参数，元素类型和容器类型，元素类型必要，而容器类型可选，默认<code>deque</code>，可改用<code>list</code>（链表）类型。</p></li>
<li><p><strong>==如何自己用数组实现一个队列？？？==</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Queue&lt;T&gt;::enqueue(T data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    queue_[rear_] = data;</span><br><span class="line">    rear_ = (rear_ + <span class="number">1</span>) % capacity_;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Queue&lt;T&gt;::dequeue()</span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Queue::dequeue() - Empty queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    data = queue_[front_];</span><br><span class="line">    front_ = (front_ + <span class="number">1</span>) % capacity_;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>什么时候使用宽搜？二叉树、图、矩阵、拓扑排序 </strong></p>
<ul>
<li><p><strong>树/图的遍历 Traversal in Graph</strong>: 比如给出无向连通图(Undirected Connected Graph)中的一个点，找到这个图里的所有点。</p>
<ol type="1">
<li><strong>层级遍历 Level Order Traversal</strong></li>
<li><strong>由点及面 Connected Component</strong></li>
<li><strong>拓扑排序 Topological Sorting</strong></li>
</ol></li>
<li><p><strong>最短路径 Shortest Path in Simple Graph</strong></p>
<ol type="1">
<li>最短路径算法有很多种，==BFS 是其中一种，但是必须是在<strong>Simple Graph (每条边长度都是1)</strong>中求最短路径==。</li>
<li>大部分<strong>Simple Graph</strong>中使用 BFS 算法时，都是无向图，也有可能是有向图，但是在面试中极少会出现。==A* search在面试中问过，推荐掌握。==</li>
<li>==如果问最长路径，则要用Dynamic Programming。分层：走到第i层一定会经过第i - 1层。不可以分层：DFS。==</li>
</ol></li>
<li><p>非递归的方式找所有方案 ???</p></li>
</ul></li>
<li><p><strong>二叉树中的BFS 和图的 BFS 最大的区别：</strong></p>
<p>==二叉树中无需使用 HashSet（C++: unordered_map, Python: dict) 来存储访问过的节点（丢进过 queue 里的节点）（这样做是为了避免存在环的情况，那么同一个节点就可能重复进入队列）==。</p></li>
<li><p><strong>图的表示形式</strong></p>
<ul>
<li><strong>邻接矩阵 Adjacency Matrix</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">/* A[i][j] = 1 means ith node connects to/with the the jth node</span></span><br><span class="line"><span class="comment">上式中，0号点和3号点有连边。1号点和2号点有连边。当然，每个点和自己也是默认有连边的。图中的 `0` 表示不连通，`1` 表示连通。邻接矩阵我们可以直接用一个二维数组表示，如`int[][] matrix;`。这种数据结构因为耗费 O(n^2) 的空间，所以在稀疏图上浪费很大，因此并不常用。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>邻接表 Adjacency List - 相当于Adjacency Matrix的稀疏表示</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"><span class="comment">/* A[i] is a list/vector of nodes who connect with ith node</span></span><br><span class="line"><span class="comment">上图表示 0 和 1 之间有连边，1 和 2 之间有连边，1 和 3 之间有连边。即每个点上存储自己有哪些邻居（有哪些连通的点）。</span></span><br><span class="line"><span class="comment">而邻接矩阵因为耗费空间过大，我们通常在工程中都是使用邻接表作为图的存储结构。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用HashMap 和 HashSet 搭配的方式来实现<strong>Adjacency Matrix</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;T, <span class="built_in">unordered_set</span>&lt;T&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通常这种hashmap的实现可以换成vector&lt;vector&lt;T&gt;&gt;来表示，但是如果在过程中需要check是否已有某个node，用map和set会比较方便，如果不需要的话就只是用固定数量的vector，就比较省空间时间。"vector可以方便实现就用vector，不方便就还是用hashmap或者hashset"</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>而邻接矩阵因为耗费空间过大（尤其是在稀疏图上浪费很大），我们通常在工程中都是使用邻接表作为图的存储结构。</strong>另外，还可以用自定义的类来实现邻接表，但一般是在实际的工程中应用。</p></li>
<li><p><strong>拓扑排序 Topological Sorting</strong></p>
<ul>
<li><p><strong>Topological Order的定义</strong>：</p>
<p>在图论中，由一个有向无环图的顶点组成的序列，如果满足以下条件：</p>
<ol type="1">
<li><p>每个顶点出现且只出现一次；</p></li>
<li><p>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</p>
<p><strong>拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。</strong></p></li>
</ol></li>
<li><p>实际应用：</p>
<ul>
<li>检测编译时的循环依赖</li>
<li><strong>制定有依赖关系的任务的执行顺序</strong></li>
</ul></li>
<li><p>==Topological Sorting 并不是一种严格意义上的 Sorting Algorithm==。</p></li>
<li><p>==一张图的拓扑序列可以有很多个，也可能没有。== 拓扑排序只需要找到其中<code>一个</code>序列，无需找到<code>所有</code>序列。</p></li>
<li><p><strong>Topological Sorting Algorithm Description</strong> 在有向图中，如果存在一条有向边 A--&gt;B，那么我们认为这条边为 A 增加了一个==出度(<strong>out-degree</strong>)==，为 B 增加了一个==入度(<strong>in-degree</strong>)==。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Topological Sorting based on BFS</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 统计所有点的入度，并初始化拓扑序列为空。</span><br><span class="line"><span class="number">2.</span> 将所有入度为 <span class="number">0</span> 的点，放到宽度优先搜索的队列中</span><br><span class="line"><span class="number">3.</span> 将队列中的点一个一个的释放出来，放到拓扑序列中，每次释放出某个点 A 的时候，就访问 A 的相邻点（所有A指向的点），并把这些点的入度减去 <span class="number">1</span>。</span><br><span class="line"><span class="number">4.</span> 如果发现某个点的入度被减去 <span class="number">1</span> 之后变成了 <span class="number">0</span>，则放入队列中。</span><br><span class="line"><span class="number">5.</span> 直到队列为空时，算法结束。</span><br><span class="line"></span><br><span class="line">Tological Sorting based on DFS</span><br></pre></td></tr></table></figure></li>
<li><p><strong>拓扑排序的4种问法</strong></p>
<ul>
<li>return any topological order</li>
<li>whether exist topological sorder?</li>
<li>return all topological orders - <strong>DFS</strong></li>
<li>whether unique topological order? - <strong>Queue最多同时只有1个节点</strong></li>
</ul></li>
</ul></li>
<li><p><strong>BFS traversal模板</strong></p>
<ul>
<li><strong>复杂度：O(N + M) N为点数，M为边数。说是O(M)问题也不大，因为M一般都比N大。</strong></li>
<li><strong>需要分层遍历的bfs</strong>：
<ul>
<li>如果问题需要你区分开不同层级的结果信息，如binary tree level order traversal</li>
<li>简单图最短路径问题（因为要以traverse的level数量作为最短路径长度）</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; que;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;T, Hasher&gt; seen; <span class="comment">//记录是否已被访问过</span></span><br><span class="line"></span><br><span class="line">seen.insert(start);</span><br><span class="line">que.push(start);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = que.<span class="built_in">size</span>(); </span><br><span class="line">  <span class="comment">//必须单独拎出来。que.size()直接放在for loop的条件中会成为一个动态变化的值，因为这个每次loop都可能改变que的size。</span></span><br><span class="line">  <span class="comment">//所以必须先把当前层一共有多少个节点存在局部变量 size 中，才不会把下一层的节点也在当前层进行扩展。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> T &amp;head = que.front();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> T &amp;neighbor : head.neighbors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!seen.count(neighbor)) &#123;</span><br><span class="line">        seen.insert(neighbor);</span><br><span class="line">        que.push(neighbor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>无需分层遍历的bfs</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; que;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;T, Hasher&gt; seen; <span class="comment">//记录是否已被访问过(这在图中需要，但在二叉树中则不需要)</span></span><br><span class="line"></span><br><span class="line">seen.insert(start);</span><br><span class="line">que.push(start);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">  <span class="keyword">const</span> T &amp;head = que.front();</span><br><span class="line">  que.pop();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> T &amp;neighbor : head.neighbors) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!seen.count(neighbor)) &#123; <span class="comment">//check whether already visited</span></span><br><span class="line">      seen.insert(neighbor); <span class="comment">//insert the just-visited node into visited set</span></span><br><span class="line">      que.push(neighbor); <span class="comment">//push into Queue-to-explore(存储等待被拓展到下一层的节点)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set/seen 与 queue 是一对好基友，无时无刻都一起出现，往 queue 里新增一个节点，就要同时丢到 set 里。</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>对于矩阵R * C的情况，复杂度是O(RC + 2RC) = O(RC)</strong></p></li>
</ol>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//坐标变化数组(矩阵中允许四个方向的走法)</span></span><br><span class="line"><span class="keyword">int</span>[] deltaX = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] deltaY = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<ol start="11" type="1">
<li><p>其他常见实现方法：</p>
<ul>
<li><p><strong>两个队列来回迭代，来代表相邻的层级</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; q1, q2;</span><br><span class="line">q1.push(startNode);</span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q1.empty()) &#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span> = q1.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">    T head = q1.front();</span><br><span class="line">    q1.pop();</span><br><span class="line">    <span class="keyword">for</span> (all neighbors of head) &#123;</span><br><span class="line">      q2.push(neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  q1 = q2; <span class="comment">//直接通过将q1替换为q2，实现到下一层的转换</span></span><br><span class="line">  level++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用 dummy node 来间隔不同的层级</strong>。</p>
<ul>
<li>Dummy Node 一般本身不存储任何实际有意义的值，通常用作"占位"，或者链表的“虚拟头”。如很多的链表问题中，我们会在原来的头head的前面新增一个节点，这个节点没有任何值，但是 next 指向 head。这样就会方便对 head 进行删除或者在前面插入等操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;T&gt; q;</span><br><span class="line">q.push(startNode);</span><br><span class="line">q.push(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为有 dummy node 的存在，不能再用 isEmpty 了来判断是否还有没有拓展的节点了</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  T head = q.front();</span><br><span class="line">  q.pop();</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    level++;</span><br><span class="line">    q.push(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (all neighbors of head) &#123;</span><br><span class="line">    q.push(neighbor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>Summary</strong></p>
<ul>
<li>能用BFS的时候一定不要用DFS(除非面试官有特别要求)</li>
<li>找所有连通图（块）的问题，相当于是==<strong>找所有点，用BFS</strong>==。</li>
<li>找所有排列的问题，相当于是==<strong>找所有路径，用DFS</strong>==。</li>
<li>BFS的三中使用情况：
<ol type="1">
<li>图的遍历(由点及面，层级遍历)</li>
<li><strong>简单图</strong>最短路径</li>
<li>==拓扑排序必须掌握!!!== (依据indegree和outdegree的概念)</li>
</ol></li>
<li>是否需要层级遍历
<ol type="1">
<li><code>size = queue.size()</code></li>
</ol></li>
<li>坐标变化数组：
<ol type="1">
<li>deltaX, deltaY</li>
<li>inBound</li>
</ol></li>
</ul></li>
</ol>
<h1 id="图的遍历">图的遍历</h1>
<h2 id="binary-tree-level-order-traversal层级遍历">Binary Tree Level Order Traversal（层级遍历）</h2>
<p>Given a binary tree, return the <em>level order</em> traversal of its nodes' values. (ie, from left to right, level by level).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> results;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                TreeNode * node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                level.push_back(node-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            results.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="number-of-islands由点及面">Number of Islands（由点及面）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_x = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_y = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = m &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                bfs(grid, i, j); <span class="comment">//由点及面</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bfs traversal（由点及面）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">//调用此函数时m肯定是不为0的</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;r, c&#125;);</span><br><span class="line">        grid[r][c] = <span class="number">0</span>; <span class="comment">//note as visited by modifying into 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//explore neighbors</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    pair&lt;int, int&gt; next(curr.first + delta_x[j], curr.second + delta_y[j]);</span><br><span class="line">                    <span class="keyword">if</span> (next.first &lt; <span class="number">0</span> || next.first &gt;= m || next.second &lt; <span class="number">0</span> || next.second &gt;= n) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[next.first][next.second] == <span class="number">1</span>) &#123;</span><br><span class="line">                        q.push(next);</span><br><span class="line">                        grid[next.first][next.second] = <span class="number">0</span>; <span class="comment">//note as visited by modifying into 0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="serialize-and-deserialize-binary-tree-层级遍历">Serialize and Deserialize Binary Tree (层级遍历)</h2>
<p>Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called <code>serialization</code> and reading back from the file to reconstruct the exact same binary tree is <code>deserialization</code>.</p>
<ul>
<li><code>serialize</code>: This method will be invoked first, you should design your own algorithm to serialize a binary tree which denote by a root node to a string which can be easily deserialized by your own "deserialize" method later.</li>
<li><code>deserialize</code>: This method will be invoked second, the argument data is what exactly you serialized at method "serialize", that means the data is not given by system, it's given by your own serialize method. So the format of data is designed by yourself, and deserialize it here as you serialize it in "serialize" method.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在bfs的同时直接转成expected string，而不经过中间阶段（vector of nodes）</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ans += <span class="string">"#,"</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (to_string(node-&gt;val) + <span class="string">","</span>);</span><br><span class="line">            q.push(node-&gt;left);</span><br><span class="line">            q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.erase(ans.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">//删掉最后的','</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="function">TreeNode * <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> &amp;data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//vector&lt;string&gt; vals = split(data, ",");</span></span><br><span class="line">      	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vals;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> token;</span><br><span class="line">        <span class="keyword">while</span>(getline(ss, token, <span class="string">','</span>)) &#123;</span><br><span class="line">            vals.push_back(token);</span><br><span class="line">        &#125;</span><br><span class="line">      	</span><br><span class="line">        TreeNode * root = <span class="keyword">new</span> TreeNode(atoi(vals[<span class="number">0</span>].c_str())); <span class="comment">//先要确定root</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; q; <span class="comment">//用queue只是为了实现level order traversal</span></span><br><span class="line">        q.push(root);</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//最关键的部分!!!</span></span><br><span class="line">        <span class="keyword">bool</span> isLeftChild = <span class="literal">true</span>; <span class="comment">//初始情况下是先走left child</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vals[i] != <span class="string">"#"</span>) &#123;</span><br><span class="line">                TreeNode * node = <span class="keyword">new</span> TreeNode(atoi(vals[i].c_str()));</span><br><span class="line">                <span class="keyword">if</span> (isLeftChild) q.front()-&gt;left = node;</span><br><span class="line">                <span class="keyword">else</span> q.front()-&gt;right = node;</span><br><span class="line">                q.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isLeftChild) q.pop(); <span class="comment">//关键步骤：当一个node的leftChild和rightChild都已经连接之后，就pop掉queue里这个parent。</span></span><br><span class="line">            isLeftChild = !isLeftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//split according to delim可以用stl的getline(ss, token, delim)来代替。</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="built_in">string</span> &amp;data, <span class="built_in">string</span> delim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastInd = <span class="number">0</span>, ind;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; results;</span><br><span class="line">        <span class="keyword">while</span>((ind = data.<span class="built_in">find</span>(delim, lastInd)) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = data.substr(lastInd, ind - lastInd);</span><br><span class="line">            results.push_back(tmp);</span><br><span class="line">            lastInd = ind + delim.<span class="built_in">size</span>(); <span class="comment">//update start searching index</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//单独push最后一个substring</span></span><br><span class="line">        <span class="keyword">if</span> (lastInd &lt; data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = data.substr(lastInd, data.<span class="built_in">size</span>() - lastInd);</span><br><span class="line">            results.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="clone-graph">Clone Graph</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bfs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="comment">//用map的目的一是为了后面去check是否visited，二是为了建立一一对应的关系而实现deepcopy.</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode* <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        UndirectedGraphNode* newNode = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class="line">        <span class="built_in">map</span>[node] = newNode;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;UndirectedGraphNode*&gt; q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            UndirectedGraphNode* curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode* neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(neighbor) == <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="built_in">map</span>[neighbor] = <span class="keyword">new</span> UndirectedGraphNode(neighbor-&gt;label);</span><br><span class="line">                    q.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>[curr]-&gt;neighbors.push_back(<span class="built_in">map</span>[neighbor]); <span class="comment">//!!!</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dfs</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode* <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(node) == <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">map</span>[node] = <span class="keyword">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode* neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">                <span class="built_in">map</span>[node]-&gt;neighbors.push_back(cloneGraph(neighbor));<span class="comment">//clongGraph return的是和输入对应的copied node</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="简单图最短路径">简单图最短路径</h1>
<h2 id="shortest-path-in-undirected-graph">Shortest Path in Undirected Graph</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for Undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="built_in">vector</span>&lt;UndirectedGraphNode*&gt; graph, UndirectedGraphNode* A, UndirectedGraphNode* B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;UndirectedGraphNode*&gt; q;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;UndirectedGraphNode*&gt; visited; <span class="comment">//记录visited，避免重复</span></span><br><span class="line">        q.push(A);</span><br><span class="line">        visited.insert(A);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                UndirectedGraphNode* curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (UndirectedGraphNode* neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) != visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (neighbor == B) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.push(neighbor);</span><br><span class="line">                    visited.insert(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双向宽度优先搜索算法bidirectional-bfs">双向宽度优先搜索算法（<strong>Bidirectional BFS</strong>）</h2>
<ul>
<li><p>无向图</p></li>
<li><p>所有边的长度都为 1 或者长度都一样</p></li>
<li><p>同时给出了起点和终点</p>
<p>以上 3 个条件都满足的时候，可以使用双向宽度优先搜索来<strong>求起点和终点的最短距离</strong>。</p>
<p>如果在面试中被问到了如何优化 BFS 的问题，Bidirectional BFS 几乎就是标准答案了。</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法描述：双向宽度优先搜索本质上还是BFS，只不过变成了起点向终点和终点向起点同时进行扩展，直至两个方向上出现同一个子节点，搜索结束。我们还是可以利用队列来实现：一个队列保存从起点开始搜索的状态，另一个保存从终点开始的状态，两边如果相交了，那么搜索结束。起点到终点的最短距离即为起点到相交节点的距离与终点到相交节点的距离之和。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设单向BFS需要搜索 N 层才能到达终点，每层的判断量为 X，那么总的运算量为 X ^ N. 如果换成是双向BFS，前后各自需要搜索 N / 2 层，总运算量为 2 * X ^ &#123;N / 2&#125; 。如果 N 比较大且X 不为 1，则运算量相较于单向BFS可以大大减少，差不多可以减少到原来规模的根号的量级。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doubleBFS</span><span class="params">(Node * start, Node * <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node&gt; startQ, endQ;</span><br><span class="line">  startQ.push(start);</span><br><span class="line">  endQ.push(<span class="built_in">end</span>);</span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;Node&gt; startVisited, endVisited;</span><br><span class="line">  startVisited.insert(start);</span><br><span class="line">  endVisited.insert(<span class="built_in">end</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!startQ.empty() || !endQ.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> startSize = startQ.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">step</span>++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startSize; i++) &#123;</span><br><span class="line">      Node * curr = startQ.front();</span><br><span class="line">      startQ.pop();</span><br><span class="line">      <span class="keyword">for</span> (Node * neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startVisited.count(neighbor)) &#123; <span class="comment">//重复节点</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endVisited.count(neighbor)) &#123; <span class="comment">//相交</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        startQ.push(neighbor);</span><br><span class="line">        startVisited.insert(neighbor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> endSize = endQ.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">step</span>++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; endSize; i++) &#123;</span><br><span class="line">      Node * curr = endQ.front();</span><br><span class="line">      endQ.pop();</span><br><span class="line">      <span class="keyword">for</span> (Node * neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (endVisited.count(neighbor)) &#123; <span class="comment">//重复节点</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (startVisited.count(neighbor)) &#123; <span class="comment">//相交</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">step</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        endQ.push(neighbor);</span><br><span class="line">        endVisited.insert(neighbor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不连通</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="word-ladder隐式简单图">Word Ladder（隐式简单图）</h2>
<p>Given two words (<em>start</em> and <em>end</em>), and a dictionary, find <strong>the shortest transformation sequence from <em>start</em> to <em>end</em></strong>, output the length of the sequence. Transformation rule such that:</p>
<ol type="1">
<li>Only one letter can be changed at a time</li>
<li>Each intermediate word must exist in the dictionary. (<strong>Start and end words do not need to appear in the dictionary</strong> )</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 自己的solution：BFS traverse nodes level by level; <span class="keyword">return</span> level + <span class="number">1</span> when the next node matches <span class="built_in">end</span>.</span><br><span class="line"># 一个难点在于：Implicit BFS - 要自己去构建graph，这里的每个node是<span class="built_in">string</span></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ladderLength(<span class="built_in">string</span> &amp;start, <span class="built_in">string</span> &amp;<span class="built_in">end</span>, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; &amp;dict) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="built_in">end</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//corner case</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">        q.push(start);</span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(start) != dict.<span class="built_in">end</span>()) dict.erase(start); <span class="comment">//通过erase已经访问过的string来记录为visited</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123; <span class="comment">//开始bfs</span></span><br><span class="line">            <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//explore neighbors of curr</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.<span class="built_in">size</span>(); i++) &#123; <span class="comment">//枚举替换位置</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123; <span class="comment">//枚举替换字母</span></span><br><span class="line">                        <span class="built_in">string</span> tmp = curr;</span><br><span class="line">                        <span class="keyword">if</span> (tmp[i] == <span class="string">'a'</span> + j) <span class="keyword">continue</span>;</span><br><span class="line">                        tmp[i] = <span class="string">'a'</span> + j;</span><br><span class="line">                        <span class="keyword">if</span> (tmp == <span class="built_in">end</span>) <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(tmp) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                            q.push(tmp);</span><br><span class="line">                            dict.erase(tmp); <span class="comment">//通过erase已经访问过的string来记录为visited</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++; <span class="comment">//count levels traversed during bfs</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="knight-shortest-pathgrid简单图">Knight Shortest Path（grid简单图）</h2>
<p>Given a knight in a chessboard (a binary matrix with <code>0</code> as empty and <code>1</code> as barrier) with a <code>source</code> position, find <strong>the shortest path to a <code>destination</code> position</strong>, return the length of the route. Return <code>-1</code> if destination cannot be reached.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a point.</span></span><br><span class="line"><span class="comment"> * struct Point &#123;</span></span><br><span class="line"><span class="comment"> *     int x;</span></span><br><span class="line"><span class="comment"> *     int y;</span></span><br><span class="line"><span class="comment"> *     Point() : x(0), y(0) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     Point(int a, int b) : x(a), y(b) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_x = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_y = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid, Point &amp;source, Point &amp;destination)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[destination.x][destination.y] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (source.x == destination.x &amp;&amp; source.y == destination.y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;Point&gt; q;</span><br><span class="line">        q.push(source);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">//level数就是可能走的步数</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                Point curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (Point &amp;next : get_next(curr, grid)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (next.x == destination.x &amp;&amp; next.y == destination.y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//helper</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">get_next</span><span class="params">(Point &amp;p, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Point&gt; results;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next_x = p.x + delta_x[i];</span><br><span class="line">            <span class="keyword">int</span> next_y = p.y + delta_y[i];</span><br><span class="line">            <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= m || next_y &lt; <span class="number">0</span> || next_y &gt;= n) <span class="keyword">continue</span>;<span class="comment">//out of bounds</span></span><br><span class="line">            <span class="keyword">if</span> (grid[next_x][next_y] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//避开障碍点</span></span><br><span class="line">            <span class="function">Point <span class="title">next_p</span><span class="params">(next_x, next_y)</span></span>;</span><br><span class="line">            results.push_back(next_p);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="knight-shortest-path-ii">Knight Shortest Path II</h2>
<p>起点和终点分别是左上角和右下角。移动过程中限制"只能往右移动"。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_x = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta_y = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;; <span class="comment">//only from left to right</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next_x = curr.first + delta_x[j];</span><br><span class="line">                    <span class="keyword">int</span> next_y = curr.second + delta_y[j];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (next_x &lt; <span class="number">0</span> || next_x &gt;= n || next_y &gt;= m ) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[next_x][next_y]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (visited[next_x][next_y]) <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; next = &#123;next_x, next_y&#125;;</span><br><span class="line">                    <span class="keyword">if</span> (next.first == n - <span class="number">1</span> &amp;&amp; next.second == m - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                    <span class="comment">//cout &lt;&lt; "x: " &lt;&lt; next.first &lt;&lt; " y: " &lt;&lt; next.second &lt;&lt; endl;</span></span><br><span class="line">                    visited[next.first][next.second] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DP解法：每个点都有至多4个前缀点，直接求最小值转移即可。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">f</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, INT_MAX))</span></span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">              	<span class="comment">//以下四种情况分别对应四个前缀点</span></span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">2</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; j - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">2</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i + <span class="number">1</span>][j - <span class="number">2</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; f[i - <span class="number">2</span>][j - <span class="number">1</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">2</span> &lt; n &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; f[i + <span class="number">2</span>][j - <span class="number">1</span>] != INT_MAX) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i + <span class="number">2</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (f[n - <span class="number">1</span>][m - <span class="number">1</span>] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>#拓扑排序问题</p>
<h2 id="topological-sorting原型">Topological Sorting（原型）</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for Directed graph.</span></span><br><span class="line"><span class="comment"> * struct DirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;DirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     DirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; <span class="title">topSort</span><span class="params">(<span class="built_in">vector</span>&lt;DirectedGraphNode*&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Calculating indegree</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;DirectedGraphNode*, <span class="keyword">int</span>&gt; node_to_degree;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DirectedGraphNode* neighbor : graph[i]-&gt;neighbors) &#123;</span><br><span class="line">                node_to_degree[neighbor]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*因为有些nodes在前面并没有被统计到，比如&#123;0,1,2,3,4#1,3,4#2,1,4#3,4#4&#125;这个case就没有先统计到0。</span></span><br><span class="line"><span class="comment">        所以需要这一步来检查没统计到map里的nodes，将in-degree主动设为0（这也是前面没被统计到的原因）。*/</span></span><br><span class="line">        <span class="keyword">for</span> (DirectedGraphNode* node : graph) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_to_degree.count(node) == <span class="number">0</span>) &#123;</span><br><span class="line">                node_to_degree[node] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;DirectedGraphNode*&gt; ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;DirectedGraphNode*&gt; q;</span><br><span class="line">        <span class="comment">//先是所有indegree为0的nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : node_to_degree) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.second == <span class="number">0</span>) q.push(m.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照bfs的套路来，每遇到新的indegree=0的node(要先--)，就push到queue中。</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++) &#123;</span><br><span class="line">                DirectedGraphNode* curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                ans.push_back(curr);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (DirectedGraphNode* neighbor : curr-&gt;neighbors) &#123;</span><br><span class="line">                    node_to_degree[neighbor]--;</span><br><span class="line">                    <span class="keyword">if</span> (node_to_degree[neighbor] == <span class="number">0</span>) &#123;</span><br><span class="line">                        q.push(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="course-schedule-是否可行">Course Schedule (是否可行)</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//裸拓扑排序（不考虑分层）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_multiset</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//未在prerequisites中被统计到的话，就自动归为0了。</span></span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; p: prerequisites) &#123;</span><br><span class="line">            g[p.second].insert(p.first);  </span><br><span class="line">            degree[p.first]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="comment">//push in-degree-0 nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            count++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : g[curr]) &#123;</span><br><span class="line">                degree[neighbor]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[neighbor] == <span class="number">0</span>) q.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == numCourses;</span><br><span class="line">        <span class="comment">//与count对应的node的sequence如果正好包括全部的node，那就说明形成了topologic order。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过bfs去check每一个course，是否会形成一个循环（如果有会形成循环的，则不能finish；如果没有，则能finish）。 </span></span><br><span class="line"><span class="comment">// - runtime error(一些冗长的case)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//create graph: 以每门课的prerequistes作为neighbors</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pre : prerequisites) &#123;</span><br><span class="line">            g[pre.second].insert(pre.first);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//check</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i].empty()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isCyle(i, g)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check whether course forms a cycle starting from course and ending with course</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCyle</span><span class="params">(<span class="keyword">int</span> course, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(course);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">        visited.insert(course);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[curr]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (neighbor == course) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    q.push(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="course-schedule-ii-一种拓扑order">Course Schedule II （一种拓扑order）</h2>
<ul>
<li>这里值得注意的是：对于prerequisites中可能会出现重复的情况，一种就是用multiset相同的数也都insert进去，后面再去掉；另外一种就是用unordered_set, 出现相同的情况直接跳过（不然的话，degree增加了，但实际的neighbors没有发生变化，导致出错）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">g</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;p : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[p.second].count(p.first) == <span class="number">0</span>) &#123; <span class="comment">//只是为了避免出现相同prerequisite的情况</span></span><br><span class="line">                g[p.second].insert(p.first);</span><br><span class="line">                degree[p.first]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            order.push_back(curr);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : g[curr]) &#123;</span><br><span class="line">                degree[next]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[next] == <span class="number">0</span>) q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (order.<span class="built_in">size</span>() == numCourses) <span class="keyword">return</span> order;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sequence-reconstruction-unique-order">Sequence Reconstruction (Unique Order)</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// seqs里的seq是sequence的subsequence，比如[1, 2]，这意味着1指向2。</span></span><br><span class="line"><span class="comment">// 判断是否有Unique Topological Order：每次iteration的时候queue里只有一个node，其他的做法和general的类似。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param org: a permutation of the integers from 1 to n</span></span><br><span class="line"><span class="comment">     * @param seqs: a list of sequences</span></span><br><span class="line"><span class="comment">     * @return: true if it can be reconstructed only one or false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;org, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;seqs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = org.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count the total length of all seqs</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indegree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq : seqs) &#123;</span><br><span class="line">            count += seq.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (seq.<span class="built_in">size</span>() &gt;= <span class="number">1</span> &amp;&amp; (seq[<span class="number">0</span>] &lt; <span class="number">1</span> || seq[<span class="number">0</span>] &gt; n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; seq.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seq[i] &lt; <span class="number">1</span> || seq[i] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//避免重复计算indegree，比如这个case: [[5,2,6,3],[4,1,5,2]] 5-&gt;2有两次</span></span><br><span class="line">                <span class="keyword">if</span> (graph[seq[i - <span class="number">1</span>]].count(seq[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    graph[seq[i - <span class="number">1</span>]].insert(seq[i]); <span class="comment">//相邻node之间有前后指向关系</span></span><br><span class="line">                    indegree[seq[i] - <span class="number">1</span>]++; <span class="comment">//node n 对应到 indegree的第n-1位</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*case: [1]</span></span><br><span class="line"><span class="comment">                []</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; indegree.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) q.push(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() == <span class="number">1</span>) &#123; <span class="comment">//queue should always have only one node</span></span><br><span class="line">            <span class="keyword">int</span> curr = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[curr]) &#123;</span><br><span class="line">                indegree[next - <span class="number">1</span>]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[next - <span class="number">1</span>] == <span class="number">0</span>) q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr != org[k]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//而且唯一的那一个要和unique order里的对应node一样</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> k == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Coding Practice</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>data structure</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="test-math-equations">Test Math Equations</h2>
<p><span class="math display">\[
\begin{equation} \label{eq1}
e=mc^2
\end{equation}
\]</span></p>
<p>The famous matter-energy equation <span class="math inline">\(\eqref{eq1}\)</span> proposed by Einstein...</p>
<p><span class="math display">\[
\begin{equation} \label{eq2}
\begin{aligned}
a &amp;= b + c \\
  &amp;= d + e + f + g \\
  &amp;= h + i
\end{aligned}
\end{equation}
\]</span></p>
<p>Equation <span class="math inline">\(\eqref{eq2}\)</span> is a multi-line equation.</p>
<p><span class="math display">\[
\begin{align}
a &amp;= b + c \label{eq3} \\
x &amp;= yz \label{eq4}\\
l &amp;= m - n \label{eq5}
\end{align}
\]</span></p>
<p>There are three aligned equations: equation <span class="math inline">\(\eqref{eq3}\)</span>, equation <span class="math inline">\(\eqref{eq4}\)</span> and equation <span class="math inline">\(\eqref{eq5}\)</span>.</p>
]]></content>
  </entry>
</search>
